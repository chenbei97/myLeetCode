## 解题思路
    [解题思路](#https://github.com/doocs/leetcode/blob/main/solution/0100-0199/0145.Binary%20Tree%20Postorder%20Traversal/README.md)
## 二叉树的遍历方法
    以编号1、2、3、4、5、6、7的完全二叉树为例
             1
          2     3
        4   5  6  7
    可以有两种方法直接写出遍历结果，分别从前往后和从后往前看。
    前->后：
        前序遍历：节点排序为根左右即123，然后在2和3的基础上也要满足根左右，
            所以是245和367，所以把4、5插到2右，6、7插到3右，得到1245367
        中序遍历：节点排序为左根右即213，然后在2和3的基础上也要满足左根右，
            所以是425和637，把4、5插到2两边，6、7插到3两边得到4251637
        后序遍历：节点排序为左根右即231，类似的可得到4526731

        以上是自上而下逐个元素判断比较繁琐，可以整体判断。
        如果是前序遍历，根1放在最前边，然后整体的左子树在中间，整体右子树在后边，每棵子树又可以按照相同的规则去放置，直到最后1级
        对于245，显然2放在45前边，3也放在67前边，所以整体就是1 245 367
        
        中序和后序遍历类似。

    后->前：
        虽然整体的思想提高了理解性，但是自上而下还是有些麻烦，是逐棵子树到逐个元素的方向去插入元素，所以可从最后一级具有孩子节点的左右子树来看。
        前序遍历：
            末端的左子树为245，末端右子树367，245整体是左子树应在右子树367前边，故245367，然后向上寻找1级，父节点1应在左子树前边，即1245367
        中序遍历：末端的左子树为425，末端右子树637，父节点在中间为4251637
        后序遍历：末端的左子树为452，末端右子树673，父节点在后边为4526731

### 递归解法
    核心区别是保存节点值语句所在的位置，在前中后
### 栈解法
    前序和后序遍历是类似的，压栈都是根节点先入
    
    前序遍历：根、右、左节点依次压栈，由于栈后入先出的机制，先pop的是根节点，然后是左节点，最后是右节点，那么出来的是根、左、右，得到的就是结果
    
    后序遍历：根、左、右节点依次压栈，由于栈后入先出的机制，先pop的是根节点，然后是右节点，最后是左节点，那么出来的是根、右、左，反转，左右根得到的就是结果

    中序遍历：
    
    前序遍历步骤：
    1.定义一个栈 stk,先将根节点压入栈
    2.若栈不为空,每次从栈中弹出一个节点(根节点开始)
    3.保存该节点的值
    4.先把节点右孩子压入栈,接着把节点左孩子压入栈(如果有孩子节点)
    5.重复 2-4 所以左孩子先出栈、右孩子后出栈
    6.返回结果为根、左、右

    后序遍历步骤：
    1.定义一个栈 stk,先将根节点压入栈
    2.若栈不为空,每次从栈中弹出一个节点(根节点开始)
    3.保存该节点的值
    4.先把节点左孩子压入栈,接着把节点右孩子压入栈(如果有孩子节点)
    5.重复 2-4 所以右孩子先出栈、左孩子后出栈
    6.返回结果为根、右、左，反转即得到左、右、根为后序遍历

    中序遍历步骤：
    1.定义一个栈 stk
    2.将树的左节点依次入栈,更新root,直到左节点为空,此时root为空
    3.root为空时,让root等于弹出的栈顶元素并保存,然后更新root为右节点
    直到root不为空,也就是root上移才有可能,这时右节点也入栈,保存后root又更新为左节点
    然后root又为空,root会继续更新为栈顶元素,如果栈顶元素也没有,循环退出
    4.重复 2-3 的操作
### Morris解法
    前序遍历：
    1.最开始cur=root,如果cur无左孩子,将当前节点值保存,cur向右移动(cur=cur.right)
    2.如果cur有左孩子,找到cur左子树上最右的节点,记为mostright
        2.1如果mostright的right指针指向空,将当前节点值保存,让其指向cur,cur向左移动(cur=cur.left)
        2.2如果mostright的right指针指向cur,让其指向空,cur向右移动(cur=cur.right)
    3.cur为空时停止遍历
    
    后序遍历：
    1.最开始cur=root,如果cur无右孩子,cur向左移动(cur=cur.left)
    2.如果cur有右孩子,找到cur右子树上最左的节点,记为mostleft
        2.1如果mostleft的left指针指向空,让其指向cur,cur向右移动(cur=cur.right)
        2.2如果mostleft的left指针指向cur,让其指向空,cur向左移动(cur=cur.left)
    3.cur为空时停止遍历
    cur移动之前先记录其val,前序无需反转,后序需要反转
    
    中序遍历：
    1.最开始cur=root,若cur无左孩子,将当前节点值保存,cur向右移动(cur=cur.right)
    2.如果cur有左孩子,找到cur左子树上最右的节点,记为mostright
      2.1如果mostright的right指针指向空,让其指向cur,cur向左移动(cur=cur.left)
      2.2如果mostright的right指针指向cur,将当前节点值保存,让其指向空,cur向右移动(cur=cur.right)
    3.cur为空时停止遍历
    中序遍历和前序遍历的程序完全相同，**区别是前序在2.1保存值,后序是2.2保存值**


