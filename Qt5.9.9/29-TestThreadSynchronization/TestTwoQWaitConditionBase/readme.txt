生产者将数据写入缓冲区，直到到达缓冲区的末尾，此时它从头开始重新启动，覆盖现有数据

消费者线程在生成数据时读取数据并将其写入标准错误

与单独使用互斥锁相比，等待条件可以实现更高级别的并发性

如果对缓冲区的访问仅由 QMutex 保护，则消费者线程无法与生产者线程同时访问缓冲区

然而，让两个线程同时在缓冲区的不同部分工作并没有什么坏处

该示例包含两个类：生产者和消费者，两者都继承自 QThread

用于这两个类之间通信的循环缓冲区和保护它的同步工具是全局变量

使用 QWaitCondition 和 QMutex 解决生产者-消费者问题的替代方法是使用 QSemaphore

这就是信号量示例所做的，这个示例不在这里说明

