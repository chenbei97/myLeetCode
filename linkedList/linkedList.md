## 合并两个有序链表

### recursion解法

每次比较的共同的点是：如果第1个链表的节点是空，就返回第2个链表的节点；如果第2个链表的节点是空，就返回第1个链表的节点；如果均不为空，那么应当更新某个链表节点的next指向。如果第1个链表节点的值小于第2个链表节点的值，说明以第1个节点为基础即可，然后更新第1个节点的next，而这个next的值取决于第1个节点next的值和第2个节点的值熟大熟小。当然也可以是第2个链表节点的值比较大，那就用第2个节点的next和第1个节点去比较，来更新第2个节点的next。

这样反复递归下去，直到最后有1个链表节点是空的，就开始执行退栈过程，这个空节点作为上个节点的next，上个节点又作为上上个节点的next，一路退到最后，就是真正的list1或者list2了。

### iteration解法

我自己的解法：

首先判断均为空的情况，直接返回空指针；只要不均为空，就可以循环，所以while的条件是list1为空或者list2为空。先设定1个指针t，已经初始化过，指向某个地址，然后再用ans记录这个地址，之后更新的是t->next，ans记录的是最初的t，t更新为t->next不会影响ans。

然后先考虑均不为空的情况，那么就可以比较2个值，比较之后，让t的值等于更小的那个值，然后更新t为t->next，同时也更新那个更小的list1或list2为其next。这个操作的前提是，t在更新为t->next之前，要先给t->next新建new1个节点，否则t更新完是空指针，下次再比较就会出问题。如果2个值相等，只需要让t和t->next的值都等于这个值，然后同理t更新到t->next->next之前都要事先new出个节点，再去更新list1和list2指向自己的下一个节点。但是这样可能会导致，list1和list2更新完后while直接退出。t多new了个节点，默认的值为0，所以还要加个判断条件，如果更新完后list1和list2都为空，先把new出来的t->next->next置为nullptr，再退出while，再返回ans；

如果2个节点有1个为空，直接让t的值等于非空节点的值，让t->next和非空节点的next相等接上即可，因为链表已经有序，直接退出循环。

官方解法：

前边是比较类似的程序，先设定t=new的节点，再让ans等于这个节点记录最初的t地址，但是这个节点当作是第1个节点的前1个节点。然后思路是，两个节点均不为空作为while条件，然后去比较2个节点的值，然后更新t的next为list1或list2的next；while结束以后至多有1个节点不为空，因为已经有序，让t直接接上非空节点即可。

## 找出链表相交节点

### doublePointers解法

两个链表均不为空时才可能相交，如果有一个为空直接返回nullptr。

均不为空时，定义指向两个链表头节点的指针pa和pb，如果pa不为空就移动pa到下一个节点，pb也是如此；直到某个指针遇到了空节点，例如pa遇见空节点，则让它重新指向b链表的头节点，然后一样pa不为空就更新，pb也是如此遇到空节点会指向a链表的头节点；直到pa和pb都指向同1个节点或者都指向空节点，就返回同一节点的地址或者mullptr。

找出相交节点的问题，大类上考虑2种情况，即测试案例是相交的和不相交的。

首先考虑2个链表确实有相交节点，如果2个链表的非相交节点个数是相同的，因为相交节点也是相同的，那么相交节点之间的那些非相交节点个数必定是相同的，那么一开始两个指针会同时到达相交节点，直接返回了；

如果2个链表非相交节点个数不同，也就是相交节点之前的那些节点个数不同，那么就不会同时到达相交节点，两个指针各自到达空节点后就会移动到对方的头节点身上。那么一开始指向较短链表头节点的指针，先到达空节点，然后移动到较长链表的头节点，再到相交节点，走过的路径为短链表的长度+长链表相交节点之前的节点；一开始指向较长链表头节点的指针，后到达空节点，再跳到较短链表的头节点，走过的路径为长链表的长度+短链表相交节点之前的节点；其实这两个路径是相同的，即两个指针会在第一次错过同时到达相交节点后，再次会同时到达相交节点。

如果2个链表每月相交节点，也就会同时到达空节点，返回nullptr。

### hashSet/hashTable解法

把链表A的所有节点地址用一个哈希集合或哈希表存起来，因为每个节点的地址是唯一的，所以哈希表或集合中所有地址是唯一的，链表B和链表A相同的那个地址存在说明相交，返回即可。

注：用哈希表其实也是可以的，因为存储的是节点地址，唯一就正确，只是时间变慢需要156ms，而哈希集合只需要80ms，双指针法更快，40ms。

set和map是不同的，<unordered_set> 和 <unordered_map>也是不同的。

① map和unordered_map的区别

 unordered_map存储机制是哈希表，不会根据key的大小进行排序，存储时根据key的hash值判断元素是否相同，内部元素是无序的。调用count函数返回被查找的元素个数只能是0或者1，unordered_map可类比于Python中的字典dict。

map中的元素是按照二叉搜索树(红黑树)存储，是有序的，在红黑树上查找的时间复杂度是O(logN)，相对于unordered_map的查询速度有所下降，但额外空间开销减小，map进行中序遍历会得到有序遍历。

如果需要内部元素自动排序，使用map，不需要排序使用unordered_map。

②set和unordered_set的区别

unordered_set基于哈希表，是无序的，unordered_set可类比于Python中的集合set。

set实现了红黑树的平衡二叉检索树的数据结构，插入元素时，它会自动调整二叉树的排列，把元素放到适当的位置，以保证每个子树根节点键值大于左子树所有节点的键值，小于右子树所有节点的键值；另外，还得保证根节点左子树的高度与右子树高度相等。平衡二叉检索树使用中序遍历算法，检索效率高于vector、deque和list等容器，另外使用中序遍历可将键值按照从小到大遍历出来。

③unordered_map和unordered_set的区别

set没有键值，本身就是键值。

## 对有序链表去重

### doublePointers解法

先判断root是否为空，是返回None；不是继续判断root的next是否为空，是直接返回root；不是说明至少有2个元素，使用双指针，一个fast指向root的next，另一个slow以root构建1个节点，定义ans指向初始的slow。

当fast和fast->next有一个为真时，while循环就继续。

否则判断fast和slow的值是否相等，不等则slow->next以fast的值去构建新节点，移动slow和fast到next节点。然后检测fast是否为空，为空直接退出while，这是防止fast更新为null节点后会因为比较2个值是否相等而导致错误，空指针没有val属性。

如果相等，就定义小while循环，当fast始终和slow值相等时，就会让fast更新到next，因为链表事先是有序的，也要检测fast是否为空，是退出小循环。退出小循环后，fast因为可能是空节点，所以也要继续检测fast，退出大循环。如果不是，就可以让slow->next以fast的值去构建新节点，更新slow到next。

### iteration解法

这个方法其实和双指针解法类似，但是区别在于无需使用new，空间复杂度变小，直接利用原有的root即可。

## 删除有序链表重复项

和上一道题的区别是，如果有重复的节点都不保留，而上边的重复项会保留1个。

### iteration解法

定义一个节点p，让它的下一个节点是root。然后p的next的next不为空时，就比较p的next和p的next.next，就更新p为p.next。这个意思是，一个节点后面的2个节点不相等，才能保证第1个节点确实不是重复的，才会更新当前节点为这后面的节点。要注意，p.next更新完后可能为空节点，加个判断提前退出，否则空节点是没有next属性的，大while会出错。

否则的话从这个节点后面的第1个节点开始，记录这个节点的值x，只要p.next的值没变，就更新p.next，注意：是更新p.next为p.next.next，直到不等于这个值为止，说明p.next确实不是重复项了再更新p为p.next。还要注意p.next可能更新为None的情况，要判断提前退出，否则空节点是没有val的，无法与x比较。

双指针其实也可以，但是写出来基本上和迭代法没有太多差异，不在给出。

## 删除链表倒数第n个节点

### iteration解法

先计算链表的长度，根据长度确定要移除节点的前一个节点，让这个节点的next直接指向节点的next.next即可，但是要注意移除的这个节点是否是第1个节点，如果是，直接让next为空即可。

### doublePointers解法

依据数学计算公式，假设有m个节点，要移除的是倒数第n个节点，以编号1开始的话，移除的节点位置是n-m+1，所以需要到达第n-m个节点，让它的next执行next.next即可。有个特殊情况时，n=m的时候，其实移除的就是第1个节点，因为没有第0个节点，所以这个情况要特殊处理。

定义2个指针fast和slow，一开始都指向root。现在只有一个数n，利用n可以先让fast指针到达第n+1个节点的位置。因为n可以为m，所以fast指针移动后可以是空指针，即移动m次，此时作为特殊情况，直接返回slow的next即可，因为删除的是第1个节点；如果n不为m，因为fast已经在n+1的位置，凑出n-m，自然是先让m减去n+1，也就是让fast移动到最后1个节点，位置为m，所以这样while执行了n-m-1次，判断条件是fast->next不为空，同时slow也更新。因为slow本来是在1的位置，所以移动n-m-1次就到达了位置n-m，此时让slow->next=slow->next->next即可。

### stack解法

用栈把链表的每个节点都入栈，由于栈先入后出，所以可以把栈的前n个top删掉，再次获取top就是要删除的节点的前驱节点，让它的next指向next.nex即可。

## 判断是否位环形链表

### hashTable解法

遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。那么遍历的时候用map来存储，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。



