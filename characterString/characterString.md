## 字符串退格问题

### stack解法

用2个栈去接收新构建的字符串，遍历每个字符串的字符，如果字符是'#'且栈空时跳过，否则的话如果字符是'#'但是不栈空就可以退栈1个元素，字符不是'#'就可以入栈。

最后比较2个栈的size，不相等一定不相等，相等时再依次比较每个元素。

### string解法

利用string本身也是容器，使用push_back和pop_back有同样的效果，判别重构后的字符串只需要使用"=="，不必再遍历。

### doublePointers解法

逆序遍历第1个字符串，遇见'#'时就知道有1个字符要被删除，定义要被删除字符数量的变量skip，让它增1，这个含义并不是真的删除原来字符串这个字符，而是跳过它，即逆序遍历的时候，让控制变量多减一次。如果是普通字符，它是否删除取决于skip是否为0，如果需要删除，skip在这之前已经+1，所以skip不会为0，就让它-1。如果skip已经为0，就先退出等待。

同样方法处理第2个字符串，如果有'#'也会跳过，控制变量多减一次，最后也会退出等待。

此时2个while循环都退出，分别停留的2个字符进行比较，不过比较的前提是，控制变量都大于等于0，否则会越界，如果不满足都大于等于0，但是至少有1个不为0，说明退格后2个字符串长度不一样，也可以直接返回false。在都大于等于0的条件下，去比较2个字符，此时退格的字符都已经删除，如果不相等，直接返回false即可。如果相等，应当进入下一次循环，控制变量正常的减1即可。

## 字符串括号匹配问题

### stack解法

此题的前提是字符串只由括号类型字符组成，字符串长度为奇数的话一定不匹配。

遍历字符串的每个字符，如果是左括号，入栈；如果是右括号，如果栈空或者栈顶元素不和右括号匹配，直接返回false，因为匹配的括号总是最近的那个括号，也就是栈顶。如果匹配了，就删除栈中匹配过的左括号，继续下一个字符的判断。
