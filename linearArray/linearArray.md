## 解题思路

## 找到数组的最大和最小值

### iteration解法

用两个变量记录目前最大和最小的值索引，根据数组大小n的情况来决定返回。

如果n=0，什么都没有；n=1，则最大和最小索引都是0；

如果n>1，还要判断n的奇偶性，如果是奇数，则初始最大最小值索引都从0开始，循环起始点为1；如果是偶数，就先比较a[0]和a[1]的情况，然后大的那个索引为maxIndex，小的给minIndex，循环起始点为2；这样可以保证后边的元素总是两两成对，便于比较；

开始每2个元素一组进行比较，大的那个元素和a[maxIndex]去比较，小的那个元素和a[minIndex]去比较，必要的话更新maxIndex和minIndex的值，循环结束就可以得到结果。

### recursion解法

借助分而治之的思想，这个解法是反复二分数组，直到最小单元2个或1个元素的数组，也就是当n不等于2的时候就会持续下去。如果是2个元素，用2个变量分别记录更小和更大的元素；如果是1个元素，最小和最大都是1个元素。

如果首次进入，n为0就返回2个None；如果是再次进入的，因为二分后数组的奇偶性可能发生变化，所以数组长度可能是1，则最大最小值认为是a[0]，数组调整长度为a[1:]就是[]了，这时候应当直接返回最大最小值；同理，数组长度可能是2，则最大最小值为{a[0],a[1]}或{a[1],a[0]}，调整数组的长度为a[2:]也是[]，应当直接返回，这是递归真正的终止条件。

例如，先判断n不为0以后，假设a还有2个或3个元素。此时再判断a是否等于2，如果等于2，二分后就是2个包含1个元素的数组；如果等于3，1个数组1个元素，另1个数组2个元素。然后再次进入递归，就遇见上一段所说的递归终止条件，无论是1个元素还是2个元素都会直接返回，不会再递归入栈，会不断递归退栈。

这个方法的缺点是不知道索引最大最小值在数组的位置，因为数组每次二分这个索引值就不再是原来整个数组的真实索引值了，只是各自小数组的索引位置。如果想通过这一系列小数组的索引位置倒退原数组真实的索引位置，比较困难。

另外递归法的速度甚至慢于纯循环方法，更不比说上边优化过的循环方法，代码文件测试，10000000个元素的量级下，递归花费7.16s，纯循环花费4.9s，上述优化的循环方法花费3.77s。

### stack解法(最小栈问题)

构建2个栈，一个栈负责存放push数组的所有元素，一个栈只记录最小的元素。

第2个栈初始存放的是无穷大元素，然后每次push时，都会比较栈的top元素和值val，小的入栈，初始的时候是val<inf。

然后再看pop操作，第一个栈直接pop没问题，第2个栈也要pop，因为第2个栈存放的是与第一个栈拥有的元素对应的最小元素。

top操作，直接返回栈的top即可。

获取最小值，只需要获取第2个栈的栈顶元素即可。

## 两数之和

找到2个数等于指定的数，返回这两个数的索引。

### iteration解法

C++中可以使用双while循环使用迭代器遍历也可以使用双for循环遍历，前者速度更快一些168ms左右，后者304ms。

思想是从第1个数开始，暴力匹配剩余的数，如果两数之和满足则返回索引，否则从第2个数暴力匹配剩余的数，直到最后2个数。

如果到了最后1个数，直接返回{-1,-1}。

对于Python直接使用列表双for循环即可，大约2900ms。

时间复杂度：O(n^2），空间复杂度：O(1）

### hashTable解法

哈希表是一个带有关键字的表，类似于字典，存在关键字-值的映射关系。这样查找1个元素无需比较，那么两数之和问题就可以变为对于1个元素a，表中是否存在target-a的元素，如果有返回这个元素的关键字。且由于两数之和问题，有个假设条件，就是两个数是不相等的，例如对于8而言，假如nums有3、4、5，应当返回3、5的索引而不是2个4的索引。

那么只需要实现把数组的索引和值存入哈希表，需要1次循环存入数值对；然后再次遍历每个数组元素a[i]，考量表中是否存在target-a[i]，且返回的索引不能是i。

哈希表的速度很快，C++只有12ms，Python中哈希表就是字典，为32ms。

## 三数之和

给定数组找到所有3个数和为0的三元组。

因为给定的数组元素可以有重复的，所以元素值不能作为标签，所以也就不能利用两数之和的解法来找。

### iteration解法

将数组进行从小到大排序，然后在三重循环中得到的三元数组(a,b,c)总是可以保证a≤b≤c，但是即使如此也不能保证所有重复的三元组被去掉。因为同一重循环，相邻的两个元素重复就会造成三元组重复，为了避免这个问题，还要加限制条件，即后1个元素要大于前1个元素。

### doublePointers解法

这个解法相对于上述解法进行了优化，因为在a固定时，如果b比较大，那么c应当比较小才可能和为0，根据这个可以进一步去除不必要的循环。那么可以在第2重循环的基础上，定义指针c，c指向数组的右端，随着b的取值不同，找到1个合适的c，这样的c在a+b+c＞0时肯定是不存在的，所以可以让循环条件为a+b+c>0，否则c持续向左移动，这时再遍历b和c之间可能的元素，减少了一些不必要的迭代，不过也要注意c持续向左移动也不能小于b，但是c是可以退到b的，此时说明不会再有合适的c，就没必要再继续，因为当前的b不成立，下一次b只会更大，但c又是b后面的位置，所以c更大，那么永远不可能遇见合适的c，故2重循环使用的是break而不是continue。

C++实现88 ms，Python为768ms。

## 最接近的三数之和

给一个长度为n的数组nums和 目标值target，从nums中选出三个整数，使它们的和与target最接近并返回这三个数的和。

假设条件：输入数组只存在恰好一个解，不能重复使用1个元素作为答案。

### iteration解法

也是暴力匹配法，三重循环跳过重复值后，剩下的三元组求和并与target做差得到差值，如果等于0直接返回target，如果不等于0，这个差值再与ans与target的绝对值差进行比较，如果前者的差值更小也就是更接近target，就更新ans为当前三元组的元素和，ans一开始是一个较大的值。

### doublePointers解法

第1重循环跳过重复的值后，设定两个指针分别指向i+1和n-1，这是因为数组已经有序，固定a的情况下，根据b和c的动态变化可以跳过一部分循环。现在b=nums[i+1]，c=nums[n-1]，如果运气不错，a+b+c=target，就直接返回了；如果运气不好，就要比较abs(a+b+c-target)和abs(ans-target)，如果前者小说明更接近就更新target为a+b+c；更新完后，考虑b、c如何移动的问题，取决于a+b+c-target是>0还是<0；如果是>0，说明b已经有点大了，只能向左移动c，才会让c变小，从而减小差值接近0；如果是<0，说明b有点不够大，向右移动b增大差值就可以更接近0；这个过程发安抚更新ans的值，直到j>=k意味着结束，因为j=k是取了相同的元素，与假设条件不符。

## 删除有序数组的重复项

原地删除重复出现的元素，并返回删除后数组的新长度，不能使用额外的数组空间，不需要考虑数组中超出新长度后面的元素，给定的数组是有序的。

### doublePointers解法

如果数组元素个数为0，就返回0；不为0，至少有1个元素，定义2个指针都指向数组的位置1。因为数组是有序的，重复的元素必定是连续的，那么判断当前元素和前一个元素是否相等即可。如果不相等说明不是重复的，那么就把快指针的值给慢指针，慢指针向前移动，然后再移动快指针；如果相等就不必移动慢指针，只需要移动快指针，直到快指针超过数组尾元素的位置即可结束循环，此时返回slow的位置就是新数组的长度。

## 移除指定元素

移除所有数值等于val的元素，并返回移除后数组的新长度。要求不使用额外的数组空间，元素的顺序可以改变，也不需要考虑数组中超出新长度后面的元素。

### doublePointers解法

类似于删除有序数组的重复项，区别在于双指针从0开始，当快指针没到数组尾部元素之外时，如果发现快指针指向的元素等于了指定值，就跳过，让快指针继续增加；如果不相等，说明不是指定值，就让慢指针等于快指针指向对的值，然后移动慢指针，快指针也移动。

## 合并两个有序数组

### iteration解法

直接合并两个数组即可，把第2个数组接在第1个数组后边，然后利用排序算法直接排序即可。

### doublePointers解法

定义2个指针，开始都指向2个有序数组的位置0处。大while循环，只要2个有一个没有到达对应数组的末尾位置，就执行循环。然后开始比较2个指针指向的元素，小的那个被添加进答案，然后指针+1，另一个不动。然后需要可考虑指针到达末尾位置的时候，另一个指针无需再移动，把另一个数组剩下的元素全部添加进去即可。

## 搜索旋转数组指定数

给定一个实现旋转过的有序数组，可以保证数组元素不相同。

例如[1,2,3,4,5,6,7]在loc=3的位置旋转就变成[4,5,6,7,1,2,3]

要求找到给定目标的索引位置，不存在的话返回-1

### binarySearch解法

对于有序数组，可以使用二分查找的方法查找元素，因为旋转后的2个小部分是有序的。每次二分时可以依据，arr[mid]和arr[0]的大小关系，以及target和arr[mid]的关系来缩小范围。

假如满足arr[0]<=arr[mid]，这说明在[0,mid]之间是有序的。且target<arr[mid]的话就可以缩小二分范围，调整right为mid-1，新的二分范围是[0,mid-1]，当然如果恰好arr[mid]=target时就会直接返回，也可能target>arr[mid]，那么说明target不在这个有序范围内，在另一个区间，所以调整left为mid+1。

还有一种情况，arr[0]>arr[mid]，这说明mid处于右侧区间，[mid+1,n-1]是有序的。且target>arr[mid+1]的话就可以缩小二分范围，调整left为mid+1，新的二分范围是[mid+1,n-1]；如果target<arr[mid+1]，说明target在左侧区间，调整right为mid-1，新的二分范围是[0,mid-1]。

## 判读是否2的幂

### iteration解法

从x=0开始，如果2^x小于target，就让x增1，等于直接返回true，大于就返回false

### recursion解法

递归函数，输入x，返回x+1，直到2^x大于target，就停止

### bit解法

一个满足2的幂的数，它用二进制数表示只有最高位有1个1，其它全为0。

一个普通的数，从高位开始有a个1，后边可能都是0(偶数)，也可能有1个1(奇数)。

符合2的幂的数减去1，就是高位借给1变为0，低位都+1，如数字8用1000表示，7则用0111表示。

这样的数字进行与运算，发现恰好就是0，也就是一个符合2的幂的数，它应当满足n和n-1的与运算是0，不是的话就不是2的幂数。

不过这个条件要求n>0，n=0也满足，但不是2的幂数

或者利用-n的相反数，它的二进制编码是n的补码，补码为原码取反再加+1，如1000取反是0111，再加1为1000，两者与运算为1000还是n，即n&(-n)为n的数才是2的幂数

## 找出只出现一次的数字

数组只有1个元素出现1次，其它元素都出现3次，找出这个数字。

### hashTable解法

可以使用哈希映射统计数组中每个元素的出现次数，键表示一个元素，值表示其出现的次数。

### bit解法

除了答案，其它的数字都出现了三次，这也意味着它们转为二进制数后对应的位置也都出现了3次。而二进制数只有0和1，把同一个数对应位的数字相加应当为0或者3，也就是3的倍数。

当然是无法事先知道加的3个数就是相同的，所以考虑所有数的和，那二进制的情况下，除了答案以外，对应位之和依然是0或者3的倍数，那么答案的对应位应该是所有数对应位加起来之和除3的余数，非0即1，所以这样可以确定答案该位是0还是1。所有位都过一遍，就可以知道这个数字的所有二进制位，也就得到了这个数字。

需要注意的是，如果使用的语言对有符号整数类型和无符号整数类型没有区分，那么可能会得到错误的答案。有符号整数类型的第31位是补码意义下的符号位，也就是-2^31，只有无符号整数才是2^31。python对此没有区分，所以对最高位的判断需要特殊处理。

计算每个数的位大小需要位运算。

有符号左移运算<<，例如左移2位，先把一个数转为32位二进制数，把高位舍弃2个0，在地位补2个0，如11左移2位就是1100。

在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以2的1次方，左移n位就相当于乘以2的n次方。

有符号右移运算>>，例如右移2位，也是先转为32位二进制数，低位的2个数舍弃，高位因为是整数所以补2个0，例如1101变为11。

右移一位相当于除2，右移n位相当于除以2的n次方。

根据2进制位得到10进制数，只需要在每个位总数对3的余数为1时，让ans扩大2倍，也就是和1>>i进行或等运算，对于python在i为31时最高位需要减等运算。

## 找出数组的所有子集

数组内可以保证所有数字不重复，找出素有子集，包括空集合。

### iteration解法

由于数组内的数字不重复，而这个数字只有在集合和不在集合的状态，也就是0或者1。那么n个数字，就可以用n位二进制数去描述，每一位代表每一个数字是否在集合的状态，因为存在全1或者全0，所以集合本身和空集合都不会被漏掉。

n个数字有2^n个可能，可以用(1<<n)来表示，遍历每个可能，就找到了所有集合。每个可能是一组二进制数，还要把它映射为10进制数，也就是原数组的索引。例如数组有3位数字，一共有8种可能，000到111，对于某个可能mask如101，它的含义是第1和第3个数字在集合中，然后用临时变量存储第1和3个数字。如何找到101对应的数字1和3呢？检测101就是要从地位到高位去检测，检测低位用101和1相与，检测高位就是用100相与，所以轮流检测101的每个位，就是让(1<<0)到(1<<n-1)依次和101相与，写成循环就是for(int i=0;i<n;i++) mask&(1<<i)，例如mask为101的时候，101依次与1，10，100，位运算不为0的就说明这个位置的元素在集合中。

### recursion解法

递归法就是从数组的第1个数字开始，一直到最后1个数字，轮流确定每个数字的状态，0或1，也就是在集合中或者不在集合中。进入递归前，当前数字cur已经被确定，可以是加入集合，被添加到t，也可以不加入集合，已经添加的再pop即可，也进入递归。第1次递归尽头是全部数字都在集合，这个集合被添加进答案后准备开始回溯，也就是不添加cur时也是一个集合。由此从序列1个元素不缺，到缺1个元素再到缺2个元素，如此重复回溯，直到最后，t里边没有元素了，空集合也会被添加进ans，递归结束。

个人感觉在这还是有些不好想象的，姑且记住吧。















