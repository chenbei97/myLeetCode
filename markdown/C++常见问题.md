<!--
 * @Author: chenbei
 * @Date: 2022-02-28 07:54:12
 * @LastEditTime: 2022-03-16 08:26:46
 * @Description: frequently asked questions for C + + interview
 * @FilePath: \myLeetCode\C++常见问题.md
 * A boy without dreams
-->
## 什么是命名空间

命名空间是一种将库名称封装起来的办法，通过这种方法可以避免和应用程序发生命名冲突的问题。例如想使用cin和cout对象需要包含头文件< string >和< iostream>的同时，必须使用标准命名空间std。

## C++编译过程

编译过程分为3个过程：编译，汇编和链接过程。其中编译过程分为（编译预处理、编译），编译预处理就是处理宏定义的展开，之后将cpp文件编译为.s的汇编代码，然后汇编过程生成机器指令.o文件，但是可能几个cpp文件有互相引用的情况，这还需要链接。链接分为动态链接和静态链接。静态链接就是把代码从静态库拷贝出来放到最终的可执行程序中，这些代码会被放到该进程的虚拟地址空间，缺点是浪费空间，重编译速度慢但是执行速度快，有点像inline内联函数一样。动态链接是在程序执行的时候，才会把代码映射到执行的虚拟地址，在内存中只有一份拷贝，节省内存，更新方便。链接完毕之后会生成可执行文件。

## C++内存管理

C++ 内存分区：栈、堆、全局/静态存储区、常量存储区、代码区。

**栈**：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放。

**堆**：动态申请的内存空间，程序执行结束还没有释放，操作系统会自动回收。、

**全局区/静态存储区**：存放全局变量和静态变量，程序运行结束操作系统自动释放，C 语言中，未初始化的放在 .bss 段中，初始化的放在 .data 段中，C++ 中不再区分。

**常量存储区**（.data 段）：存放的是常量，不允许修改，程序运行结束自动释放。

**代码区**（.text 段）：存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。从操作系统的本身来讲，以上存储区在内存中的分布是如下形式(从低地址到高地址)：.text 段 --> .data 段 --> .bss 段 --> 堆 --> unused --> 栈 --> env

```c++
#include <iostream>
using namespace std;

/*
说明：C++ 中不再区分初始化和未初始化的全局变量、静态变量的存储区，如果非要区分下述程序标注在了括号中
*/

int g_var = 0; // g_var 在全局区（.data 段）
char *gp_var;  // gp_var 在全局区（.bss 段）

int main()
{
    int var;                    // var 在栈区
    char *p_var;                // p_var 在栈区
    char arr[] = "abc";         // arr 为数组变量，存储在栈区；"abc"为字符串常量，存储在常量区
    char *p_var1 = "123456";    // p_var1 在栈区；"123456"为字符串常量，存储在常量区
    static int s_var = 0;       // s_var 为静态变量，存在静态存储区（.data 段）
    p_var = (char *)malloc(10); // 分配得来的 10 个字节的区域在堆区
    free(p_var);
    return 0;
}
```

## ++i和i++的区别

如果是单独的语句，并没有区别。得到的结果是一样的。在for循环中i++和--i作为expression也是没有区别的，因为expression是循环结束后计算出来，最后结果不会改变。

不过i++语句是需要一个临时变量取存储返回自增前的值，而++i不需要。这样就导致使用i++时系统需要先申请一段内存空间，然后将值塞进去，最后不用了才去释放。

```c++
i++;
--j;
```

如果是表达式，就会有所区别。i++是表达式先用i的值，再让i自增，所以n的值为1；++j是先把j增加1，所以表达式的值变为2，故m=2。

```c++
int i,j = 1;
int n = i++;
int m = ++j;
```

## C和C++有什么区别？

C++是面向对象的语言(引入类)，而C是面向过程的语言；

C++引入new/delete运算符，取代了C中的malloc/free库函数；

C++引入引用的概念，而C中没有；

C++引入函数重载的特性，而C中没有；

## new/delete和malloc/free之间有什么关系

new与delete直接带具体类型的指针，**malloc和free返回void类型的指针**

**new类型是安全的**，而malloc不是。例如int *p = new float[2]就会报错；而int p = malloc(2sizeof(int))编译时编译器就无法指出错误来。

new一般分为两步：new操作和构造。new操作对应与malloc，但**new操作可以重载**，**可以自定义内存分配策略**，不做内存分配，甚至分配到非内存设备上，而malloc不行。

new调用构造函数，malloc不能；delete调用析构函数，而free不能。

malloc/free需要库文件stdlib.h的支持，new/delete则不需要。

malloc申请的内存不能通过delete释放，new申请的内存也不能用free释放。

malloc /free主要为了兼容C，new和delete 完全可以取代malloc /free的。**malloc /free的操作对象都是必须明确大小的**。**new 和delete会自动进行类型检查**，也不需要自己明确内存大小，**malloc/free不能执行构造函数与析构函数**，所以动态对象它是不行的。

## 内存块太小导致malloc和new返回空指针，该怎么处理

对于malloc来说，需要判断其是否返回空指针，如果是则马上用return语句终止该函数或者exit终止该程序；

对于new来说，默认抛出异常，所以可以使用try...catch...代码块的方式。还可以使用set_new_handler函数的方式，如果new不能满足内存分配请求，no_more_memory会被反复调用，所以new_handler函数必须完成以下事情：

让更多内存可被使用，可以在程序一开始执行就分配一大块内存，之后当new_handler第一次被调用，就将这些内存释放还给程序使用；

使用另一个new_handler；

卸除new_handler返回空指针，这样new就会抛出异常；

直接抛出bad_alloc异常；

直接使用abort或exit函数。

## 内存的分配方式有几种？

在栈上分配：在执行函数时，局部变量的内存都可以在栈上分配，函数结束时会自动释放；

从堆上分配：由 new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个 delete；

从自由存储区分配：如果说堆是操作系统维护的一块内存，那么自由存储区就是C++中通过new和delete动态分配和释放对象的抽象概念。需要注意的是，自由存储区和堆比较像，但不等价；

从常量存储区分配：特殊的存储区，存放的是常量，不可修改；

从全局/静态存储区分配：全局变量和静态变量被分配到同一块内存中，该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0。

## static的修饰作用

①修饰局部变量：该变量在静态存储区分配内存，只能在首次函数调用中进行首次初始化，之后的函数调用不再进行初始化；其生命周期与程序相同，但其作用域为局部作用域，并不能一直被访问；
②修饰全局变量：该变量在静态存储区分配内存；在声明该变量的整个文件中都可见，文件外不可见；
③修饰普通函数：在声明该函数的整个文件中可见，文件外不可见，可在多人协作时避免同名函数冲突；
④修饰成员变量：所有类对象都只维持一份拷贝，可以实现不同对象间数据共享，无需实例化对象即可访问；不能在类内部初始化，一般在类外部初始化，并且初始化时不加static；
⑤修饰成员函数：该函数不接受this指针，只能访问类的静态成员，无需实例化对象即可访问。

## define和const有什么区别？

编译器处理方式不同：#define宏是在预处理阶段展开，不能对宏定义进行调试，而const常量是在编译阶段使用；

类型和安全检查不同：#define宏没有类型，不做任何类型检查，仅仅是代码展开，可能产生边际效应等错误，而const常量有具体类型，在编译阶段会执行类型检查；

存储方式不同：#define宏仅仅是代码展开，在多个地方进行字符串替换，不会分配内存，存储于程序的代码段中，而const常量会分配内存，但只维持一份拷贝，存储于程序的数据段中；

定义域不同：#define宏不受定义域限制，而const常量只在定义域内有效。

## typedef 和define 有什么区别

typedef 用来定义一种数据类型的别名，增强程序的可读性。define 主要用来定义常量，以及书写复杂使用频繁的宏。

typedef 是编译过程的一部分，有类型检查的功能。define 是宏定义，是预编译的部分，其发生在编译之前，只是简单的进行字符串的替换，不进行类型的检查。

typedef 有作用域限定，define 不受作用域约束，只要是在define 声明后的引用都是正确的。

对指针的操作不同，typedef 和define 定义的指针时有很大的区别。

typedef 定义是语句，句尾要加上分号。而define不是语句，无需在句尾加分号。

## 静态链接和动态链接有什么区别

静态链接是在编译链接时直接将需要的执行代码拷贝到调用处；优点在于程序发布时不需依赖库，可独立执行，缺点在于程序的体积会相对较大，且如果静态库更新之后，所有可执行文件需要重新链接；

动态链接是在编译时不直接拷贝执行代码，而是在程序运行时将信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定代码时，在共享执行内存中寻找已经加载的动态库可执行代码，实现运行时链接；优点在于多个程序可以共享同一个动态库，节省资源；缺点在于由于运行时加载，可能影响程序的前期执行性能。

## 变量的声明和定义有什么区别

变量的定义为变量分配地址和存储空间， 变量的声明不分配地址。一个变量可以在多个地方声明， 但是只在一个地方定义。加入extern 修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。

```c++
int main() 
{
   extern int A;
   //这是个声明而不是定义，声明A是一个已经定义了的外部变量
   //注意：声明外部变量时可以把变量类型去掉如：extern A;
   dosth(); //执行函数
}
int A; //是定义，定义了A为整型的外部变量
```

## 简述#ifdef、#else、#endif和#ifndef的作用

利用#ifdef、#endif将某程序功能模块包括进去，以向特定用户提供该功能，在不需要时用户可轻易将其屏蔽。

```c++
#ifdef MATH
#include "math.c"
#endif
```

在子程序前加上标记，以便于追踪和调试。

```c++
#ifdef DEBUG
printf ("Indebugging......!");
#endif
```

虽然不用条件编译命令而直接用if语句也能达到要求，但那样做目标程序长（因为所有语句都编译），运行时间长（因为在程序运行时间对if语句进行测试）。而采用条件编译，可以减少被编译的语句，从而减少目标程序的长度，减少运行时间。

## 结构体可以直接赋值吗

声明时可以直接初始化，同一结构体的不同对象之间也可以直接赋值，但是当结构体中含有指针成员时一定要小心，深拷贝。

## extern变量的使用

分3个情况来说明：

① 外部变量在本文件定义：该全局变量的作用域从变量的定义开始到文件末尾，如果在定义之前有函数引用了这个全局变量，就会报未定义标识符的错误，所以可在调用之前先声明这个变量为外部的，那么编译器就会优先从本文件去寻找，如果没找到，会在同一目录下的文件寻找。全局函数和全局变量的含义类似，如果在调用前没有声明过也会报错，同样可以使用extern+函数原型的办法去声明，本文件找不到就去其他文件寻找。

② 外部变量在其他文件定义：假如A文件定义了全局变量a=10，在B文件声明a为外部变量后，打印a的值就是10，优先从B文件寻找没找到就会从其它文件寻找，在A文件可以找到。但是B文件不能再次定义a=5，无论在B文件的哪个位置定义，记住定义只能有一次。

③ 外部变量在头文件定义：唯一的区别是，因为头文件可以被多次包含，这个外部变量可以在任何文件中被首次定义，但是一经定义，其他文件不能够再定义，只能够使用。所以如果非必要，不是常量表达式/数组的话不要在头文件中定义全局变量/外部变量。

## 宏定义的作用

① 宏定义可用宏代替一个在程序中经常使用的常量，常量需要修改时可以只修改宏，方便修改；

② 使用带参数的宏定义可完成函数调用的功能，减少系统开销，提高运行效率；

③ 宏定义在预处理阶段即进行了宏展开，在执行时不需要转换，可以当地执行。函数的话在调用时需要先保留现场，执行完毕后再回到现场，如果函数的功能比较简单，则离开-回到现场的花费时间可能大于函数本身执行花费的时间，宏定义不会，直接执行；

④ 宏定义相对于const常量来说，在编译阶段无法执行变量类型检查，在编译时就将定义的变量全部替换，可能会有安全问题；

⑤ 宏定义没有内存开销，仅仅是编译时期替换，不能取地址；const常量则是运行时期的变量，类型不匹配会检查出来，需要分配内存，可以取地址；

⑥ 宏定义有括号边界效应，因为宏定义的时候，各个分量未加括号，传递的参数是变量表达式，系统展开后可能由于括号优先级的问题结果不一定是正确的。

例如，在头文件定义了宏函数。

```c++
#define MUL(A,B) A*B
```

使用宏时，代码文件传入了这样的参数。

```c++
int a=1,b=2,c=3,d=0;
d=MUL(a+b,c)
```

实际上编译过程展开为

```c++
d=a+b*c
```

这时传入的是表达式，并没有把括号一起传进去

解决方法是给每个分量都加上括号，就可以避免此类问题

```c++
#define MUL(A,B) ((A)*(B))
```

再如，宏定义一个结构体指针类型，结尾没有分号。

```c++
#define dps struct s *
```

使用的时候，如下

```c++
dps p1,p2;
```

编译阶段实际展开为

```c++
struct s * p1,p2;
```

因为宏定义只是单纯的替换dps，这样p2就是普通的结构体类型，而不是指针类型了。

这种解决方法是不使用宏定义，而是使用别名typedef，注意是有分号的。

```c++
typedef  struct * dps ;
```

⑦ 宏定义加了括号也不一定保证结果正确；

例如，宏定义比较函数。

```c++
#define MIN(A,B) ((A)<(B)?(A):(B))
```

调用宏。

```c++
int a=1,b=3,min=0;
min=MIN(a++,b);
```

经过编译替换展开后，就成了

```c++
min=((a++)< (b)?(a++):(b));
```

先计算a++的表达式为1，计算逻辑表达式1<3是成立的，此时a已经为2，然后返回的是a++，等号右侧结束运算，a变成了3，并不是想要的结果1。

解决方案是使用template inline函数替代宏函数。因为这里的MAX是真正的函数，它遵守作用域和访问规则，还可以进行类型检查，还可以写出限制在class内的私有inline函数，而宏定义是无法做到的。

```c++
template<typename T>
inline T MAX(const T&x, const T&y){
    return x+y;
}
```

## inline的作用

适用于频繁调用的、短小的函数代码。

inline函数是指，函数体可以在调用点直接展开，而无需调用，省去调用的开销。如果函数体比较小，这种声明为inline是值得的，但是如果函数体很长，例如存在循环或者递归等，就不要使用inline，这会带来代码的膨胀和较高的空间开销。

因为inline函数必须再调用点处执行，所以与普通函数不同，在每个调用点处都需要定义，也就是a.cpp和b.cpp使用inline函数时，都要定义，如果2个定义不同程序就会出现未定义的行为。所以为了避免这种事，常常把inline函数声明在头文件中，这样它对每个调用都是相同的定义。

另外inline是用于实现的关键字而非声明的关键字，所以inline要与函数定义体连在一起才起作用。声明不加inline这样做的原因是，用户无需通过阅读声明了解到这个函数是否需要内联。

```C++
inline void swap(int &x, int &y);// 与函数声明连接不起作用
void swap(int &x, int &y){ // 函数体
    int t = x;
    x = y;
    y = t;
}

void swap(int &x, int &y); // 函数声明
inline void swap(int &x, int &y){ // 与函数体在一起才起作用
    int t = x;
    x = y;
    y = t;
}
```

对于成员函数，一般是类的声明和实现放在2个文件中，这样做的原因是因为如果函数实现放在类的声明中，就会自动成为inline函数。这样类的每个实例生成都会复制一份代码，而默认构造、复制构造和析构函数等常常有较大的函数体，这样的空间开销是不必要的，调用的开销远远小于inline。

```c++
class A{
	public:
		void swap(int &x, int &y){ // 函数体在声明中实现会自动成为inline函数
            int t = x;
            x = y;
            y = t;
        }
}
```

如果swap不想作为inline函数，应该类外声明或者包含类A头文件的cpp文件定义。

```c++
// 写在包含类A头文件的cpp文件或者写在类A的头文件外部
void A::swap(int &x, int &y){ // 每个A的实例去调用这个函数,定义只有1分避免复制代码造成空间开销
    int t = x;
    x = y;
    y = t;
}
```

如果swap一定要声明为inline，为了良好的编程风格，也应当在类外声明为inline。

```c++
class A{
	public:
		void swap(int &x, int &y);
}
inline void A::swap(int &x, int &y){ //类外声明为inline函数
    int t = x;
    x = y;
    y = t;
}
```

inline函数常常用于替代宏函数，是真正的函数，有私有化的定义，可以限制作用域。

## 基类与子类指针销毁、纯虚函数的问题

### 基类与子类的互调问题

① 父类的实例可以被子类实例复制，但是反过来不成立。

说明：子类可以退化为父类，子类对象尝试赋值给父类对象时，会有一个隐式转换，将子类中父类有的成员进行复制。但是父类的实例不能赋值给子类对象，因为子类对象的某些成员在父类中没有定义。

② 父类的引用可以指向子类，但是反过来不成立。

说明：还是相同的原因，子类可以退化为父类的引用，父类不能进化为子类的引用，子类的某些成员引用不到。

③ 父类的指针可以指向子类，但是反过来不成立。

说明：同理，父类的指针可以指向子类中父类的成分，存在一个隐式转换，但是反过来子类指针是无法指向父类中不存在的子类成员。如果一定要子类指针指向父类，只能通过强转类型，但是这样不符合习惯也比较危险。

以上三种同样的结论是：

子类只能调用子类的方法，基类只能调用基类的方法。

如果子类和基类具有同名函数，根据指针的原型来确定，而不是根据指针实际指向的对象类型确定调用哪个函数，也就是应调用父类的同名函数。如果希望调用子类的同名函数，就要引入虚函数virtual，在下文会提到。

### 基类指针销毁问题

 如果基类不存在虚函数，也没有虚析构函数，基类的指针指向new出来的子类对象后，再去删除基类指针，会出现未有定义和资源泄露的情况。

```c++
class base{
    public:
    	base(){cout<<"base created\n";}
    	~base(){cout<<"base destroyed\n";}
}
class derived{
    public:
    	derived(){cout<<"derived created\n";}
    	~derived(){cout<<"derived destroyed\n";}
}
base * p = new derived();//基类指针指向子类对象
delete base;
base = nullptr;
// 终端输出结果
base created;
derived created;
base destroyed; // 基类创建->子类创建->基类销毁->??子类未被销毁(或者说子类析构函数未被调用)
```

### 虚函数virtual的引入目的

为了指向子类对象的基类指针销毁问题，引入了virtual函数，这样可以调用子类的析构函数。

关于虚函数的性质要进行几点说明：

① 纯虚拟函数不许定义其具体动作，它的存在只是为了在衍生类被重新定义，如果不需要体现多态性，不要定义虚函数；

② 拥有纯虚拟函数的类，就是抽象类，它们是不能够被实例化的，只能被继承；

③ 一个继承类没有改写父类中的纯虚函数，那么它也是抽象类，也不能被实例化；

④ 抽象类不能被实例化，但是可以定义指向抽象类的指针，以便于操纵各个衍生类；

⑤ 虚函数衍生下去仍然是虚拟函数，而且还可以省略掉关键字virtual，也就是衍生类不再特别声明为virtual也是虚函数；

⑥ 如果类有虚函数，那类就应该有一个虚析构函数。

在父类指针指向子类对象做对象销毁时，由于析构函数不是虚函数，则delete时，父类指针只能调用父类自己的析构函数，这就造成了上述对象部分销毁的错误状况，现在引入虚析构，就可以让父类指针销毁时调用子类的析构函数。

```c++
class base{
    public:
    	base(){cout<<"base created\n";}
    	virtual ~base(){cout<<"base destroyed\n";} // 现在定义为virtual函数
}
class derived{
    public:
    	derived(){cout<<"derived created\n";}
    	~derived(){cout<<"derived destroyed\n";}
}
base * p = new derived();//基类指针指向子类对象
delete base;
base = nullptr;
// 终端输出结果
base created;
derived created;
derived destroyed; // 后被创建,先被销毁
base destroyed; // 基类创建->子类创建->子类销毁->父类销毁
```

## 纯虚函数、非纯虚函数、非虚函数

纯虚函数的目的是为了让派生类**只继承函数接口，派生类必须提供实**现。派生类可以为纯虚函数提供定义，但使用时需要指明所属的基类。

非纯虚函数的目的是，让派生类指**定接口继承与缺省实现继承**。派生类可以生成自己的实现方式，若不提供则使用基类的实现方式。

非虚函数的目的是，让派生类**继承函数接口与一份强制性实现**，派生类不应更改该实现。非虚函数在基类指针指向子类对象时因为是静态绑定，只会执行基类的那个函数。

## 虚函数表是什么

虚函数表是针对类的，类的所有对象共享这个类的虚函数表，因为每个对象内部都保存一个指向该类虚函数表的指针vptr，每个对象的vptr的存放地址都不同，但都指向同一虚函数表。

## 基类的构造函数不能定义为虚函数

虚函数的调用依赖于虚函数表，而指向虚函数表的指针vptr需要在构造函数中进行初始化，所以无法调用定义为虚函数的构造函数。

## 基类的析构函数需要定义为虚函数

为了实现动态绑定，基类指针指向派生类对象，如果析构函数不是虚函数，那么在对象销毁时，就会调用基类的析构函数，只能销毁派生类对象中的部分数据，所以必须将析构函数定义为虚函数，从而在对象销毁时，调用派生类的析构函数，从而销毁派生类对象中的所有数据。

## 构造函数和析构函数能抛出异常吗

语法的角度来说，构造函数可以抛出异常，但尽量不要抛出异常否则可能导致内存泄漏。

析构函数不可以抛出异常，如果析构函数抛出异常，则异常点之后的程序，比如释放内存等操作，就不会被执行，从而造成内存泄露的问题，同时也不要传播异常导致未定义行为

## 让一个类不能实例化

将类定义为抽象类（也就是存在纯虚函数）或者将构造函数声明为private

## 多继承存在什么问题？如何消除二义性

基类之间或基类与派生类之间发生成员同名时，将出现对成员访问的不确定性，即同名二义性，可以利用**作用域运算符`::`**，用于限定派生类使用的是哪个基类的成员，或派生类中**定义同名成员**，覆盖基类中的相关成员。

当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类的成员时，将产生另一种不确定性，即路径二义性。除了上述2个方法，使用**虚继承**，使得不同路径继承来的同名成员在内存中只有一份拷贝。

## 类A是空类，sizeof(A)值为多少

sizeof(A)的值为1，因为编译器需要区分这个空类的不同实例，分配一个字节，可以使这个空类的不同实例拥有独一无二的地址。

## 覆盖和重载之间有什么区别

覆盖是指派生类中重新定义的函数，其函数名、参数列表、返回类型与父类完全相同，只是函数体存在区别。覆盖只发生在类的成员函数中。

重载是指两个函数具有相同的函数名，不同的参数列表，不关心返回值；根据传递的参数列表来判断调用哪个函数；重载可以是类的成员函数，也可以是普通函数。

## 虚函数和多态的理解

多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。

在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。

## C++中struct和class的区别

默认继承权限不同，class继承默认是private继承，而struct默认是public继承。

class可用于定义模板参数，像typename，但是struct不能用于定义模板参数。

为保证与C语言的向下兼容性，C++必须提供一个struct。

## 强制转换的种类

reinterpret_cast< type-id > (expression)，可以用于类型之间进行强制转换，type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。

const_cast (expression)，可以用于修改类型的const或volatile属性，常量指针和常量引用被去除常量性。

static_cast < type-id > (expression)，把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。派生类的指针或引用转换成基类表示是安全的，反过来不安全。还可用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。把空指针转换成目标类型的空指针，以及把任何类型的表达式转换成void类型。

static_cast不能转换掉expression的const、volatile、或者__unaligned属性。

dynamic_cast (expression)，有类型检查，基类向派生类转换比较安全，但是派生类向基类转换则不太安全。type-id 必须是类的指针、类的引用或者void *， type-id 是类指针类型，那么expression也必须是一个指针，如果 type-id 是一个引用，那么 expression 也必须是一个引用。dynamic_cast运算符可以在执行期决定真正的类型，也就是说expression必须是多态类型。类层次间进行上行转换时，和static_cast效果相同，下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。

## RTTI是什么，原理？

RTTI即**运行时类型识别**，其功能由两个运算符实现。typeid运算符，用于返回表达式的类型，可以通过**基类的指针获取派生类的数据类型**；dynamic_cast运算符，具有类型检查的功能，**用于将基类的指针或引用安全地转换成派生类的指针或引用**。

## C++的空类有哪些成员函数

缺省构造函数。

缺省拷贝构造函数。

省析构函数。

赋值运算符。

取址运算符。

取址运算符 const 。

## unordered_map和map

unordered_map的底层是一个防冗余的哈希表，map一般采用红黑树(RB Tree) 实现。构造函数上，unordered_map 需要hash函数，等于函数；map只需要比较函数(小于函数)。unordered_map查找速度比 map 快，查找速度基本和数据数据量大小无关，属于常数级别；而map 的查找速度是 log(n) 级别。考虑效率使用hash_map，考虑内存使用map。

## vector底层

vector底层是一个动态数组，包含三个迭代器，start和finish之间是已经被使用的空间范围，end_of_storage是整块连续空间包括备用空间的尾部。当空间不够装下数据时，会自动申请另一片更大的空间（1.5倍或者2倍）。vector的元素类型不能是引用，因为底层实现要求连续的对象排列，引用并非对象，没有实际地址。插入一个元素到vector中，由于引起了内存重新分配，所以指向原内存的迭代器全部失效。erase方法会返回下一个有效的迭代器，所以当我们要删除某个元素时，需要it=vec.erase(it)。

vector可以随机存储元素，但在非尾部插入删除数据时，效率很低，适合对象简单，对象数量变化不大，随机访问频繁的情况。

## vector如何释放空间

需要空间动态缩小，可以考虑使用deque。如果vector，可以用swap()来帮助释放内存，因为clear只清空数据不释放内存。

```c++
vector(Vec).swap(Vec); //将Vec的内存清除；
vector().swap(Vec); //清空Vec的内存；
```

## list底层

list的底层是一个双向链表，适合需要大量的插入和删除。

## deque底层

deque是一个双向开口的连续线性空间（双端队列），在头尾两端进行元素的插入跟删除操作都有理想的时间复杂度。需要从首尾两端进行插入或删除操作的时候需要选择deque

## map和set

map 、set、multiset、multimap的底层实现都是红黑树，epoll模型的底层数据结构也是红黑树，linux系统中CFS进程调度算法，也用到红黑树。

1. 每个结点或是红色或是黑色；
2. 根结点是黑色；
3. 每个叶结点是黑的；
4. 如果一个结点是红的，则它的两个儿子均是黑色；
5. 每个结点到其子孙结点的所有路径上包含相同数目的黑色结点。

set和multiset会根据特定的排序准则自动将元素排序，set中元素不允许重复，multiset可以重复。map和multimap将key和value组成的pair作为元素，根据key的排序准则自动将元素排序（因为红黑树也是二叉搜索树，所以map默认是按key排序的），map中元素的key不允许重复，multimap可以重复。

map和set的增删改查速度为都是logn，是比较高效的。

## map插入方式有哪几种

用insert函数插入pair数据

```c++
mapStudent.insert(pair<int, string>(1, "student_one"));
```

用insert函数插入value_type数据

```c++
mapStudent.insert(map<int, string>::value_type (1, "student_one"));
```

insert函数中使用make_pair()函数

```c++
mapStudent.insert(make_pair(1, "student_one"));
```

使用中括号赋值

```c++
mapStudent[1] = "student_one";
```

## 智能指针的种类

智能指针是一个RAII类模型，用于动态分配内存，其设计思想是将基本类型指针封装为（模板）类对象指针，并在离开作用域时调用析构函数，使用delete删除指针所指向的内存空间，智能指针的作用是，能够处理内存泄漏问题和空悬指针问题。分为auto_ptr、unique_ptr、shared_ptr和weak_ptr四种。

auto_ptr，独占式，同一时间只能有一个智能指针可以指向该对象。C++11被放弃，如果两个指针进行赋值，其中一个会剥夺另一个指针对资源的所有权，导致那个指针被访问时内存崩溃。另外它不能指向数组，不能作为STL容器的成员。

unique_ptr，独占式，同一时间只能有一个智能指针可以指向该对象，无法进行拷贝构造和拷贝赋值，避免了auto_ptr的问题，但是可以进行移动构造和移动赋值，即使用move函数来进行交换。

shared_ptr，共享式，多个智能指针可以指向相同的对象，使用引用计数。use_count 返回引用计数的个数；get 返回内部对象(指针)；reset 放弃内部对象的所有权或拥有对象的变更，会引起原有对象的引用计数的减少；swap 交换两个 shared_ptr 对象(即交换所拥有的对象)；该对象及相关资源会在其所指对象不再使用之后，自动释放与对象相关的资源。

weak_ptr，解决shared_ptr相互引用时，两个指针的引用计数永远不会下降为0，从而导致死锁的问题。是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象，是一种弱引用，可以绑定到shared_ptr，它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造，shared_ptr可以直接赋值给它，它也可以通过调用lock函数来获得shared_ptr。它的构造和析构不会引起引用记数的增加或减少。

## shared_ptr是如何实现

构造函数中计数初始化为1，拷贝构造函数中计数值加1；赋值运算符中，左边的对象引用计数减1，右边的对象引用计数加1，析构函数中引用计数减1；赋值运算符和析构函数中，如果减1后为0，则调用delete释放对象。

## 右值引用的作用

右值引用的主要目的是为了实现转移语义和完美转发，**消除两个对象交互时不必要的对象拷贝**，也能够更加简洁明确地定义泛型函数。

左值引用能对表达式取地址，不能取地址的就是右值，所有具名对象变量都是左值，右值不具名。因为一个C++表达式执行过程种可能会存在一些临时变量，如果表达式结束后仍然存在就是左值，否则就是右值。右值分为纯右值和将亡值，表达式结束后不存在。
左值引用是个别名，右值引用使用2个&引用符号。

## 悬挂指针与野指针有什么区别

悬挂指针：指针所指向的对象被释放，但是该指针没有任何改变，仍然指向已经被回收的内存地址。

野指针：未初始化的指针被称为野指针。

## ((void ()( ) )0)( )的含义

void (*0)( ) ：是一个返回值为void，参数为空的函数指针0。

(void (*)( ))0：把0转变成一个返回值为void，参数为空的函数指针，旧式转换。

(void )( ))0：在上句的基础上加 * 表示整个是一个返回值为void，无参数，并且起始地址为0的函数的名字。

((void ()( ))0)( )：这就是上句的函数名所对应的函数的调用。

总结：是一个返回值void，没有参数，起始地址为0的函数调用。

## 指针和引用的区别

1、指针指向对象的地址，需要解引用才能进行操作，引用是对象的一个别名

2、使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小

3、引用必须被初始化，一经初始化即不可再改变

4、返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露

5、引用的本质还是一个指针常量，也就是指针不能移动，指向常量的引用叫常饮用，是个指向常量的指针常量

6、存在const指针，不存在const引用，因为引用本身就不可更改指向无需加const声明

## 简述队列和栈的异同

队列和栈都是线性存储结构，但是两者的插入和删除数据的操作不同，队列是先进先出，栈是后进先出。另外和堆区、栈区也不是一回事，前者是一种数据结构，后者是程序的不同内存存储区域。堆一般由程序员分配释放，存取顺序任意， 若程序员不释放，程序结束时可能由OS 回收，分配方式类似于链表。栈由编译器自动分配释放，后进先出，存放函数的参数值，局部变量的值等。

## 堆和栈的区别

堆是动态分配的，其空间的分配和释放都由程序员控制；栈是由编译器自动管理的，其分配方式有两种：静态分配由编译器完成，比如局部变量的分配；动态分配由alloca()函数进行分配，但是会由编译器释放；

对堆来说，管理堆更像链表，如果申请一段空间就需要查找第一个大于申请空间的内存结点然后返回地址给申请的变量。频繁使用new/delete会造成内存空间的不连续，产生大量碎片，程序效率降低；对栈来说，不存在碎片问题，因为栈具有先进后出的特性；

堆是向着内存地址增加的方向增长的，从内存的低地址向高地址方向增长；栈是向着内存地址减小的方向增长的，从内存的高地址向低地址方向增长；

堆是不连续的内存区域，其大小可以灵活调整；栈顶和栈底是预设好的，大小固定。

## 构造一个类，使只能在堆或栈上分配内存

只能在堆上分配内存：将析构函数声明为private；

只能在栈上生成对象：将new和delete重载为private。

## 浅拷贝和深拷贝

浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享一块内存；深拷贝会创造一个相同的对象，新对象与原对象不共享内存，修改新对象不会影响原对象。

## 字节对齐的原则是什么

从偏移为0的位置开始存储；

如果没有定义#pragma pack(n)，sizeof的最终结果必然是结构内部最大成员的整数倍，不够补齐；结构内部各个成员的首地址必然是自身大小的整数倍；

定义了#pragma pack(n)，sizeof的最终结果必然是min[n,结构内部最大成员]的整数倍，不够补齐；结构内部各个成员的首地址必然是min[n,自身大小]的整数倍。

## 结构体内存对齐问题

结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。

未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐）。

c++11以后引入两个关键字 alignas与 [alignof]。其中alignof可以计算出类型的对齐方式，alignas可以指定结构体的对齐方式。

## C语言的结构体和C++的类有什么区别

C语言的结构体是不能有函数成员的，而C++的类可以有。

C语言的结构体中数据成员是没有private、public和protected访问限定的。

C语言的结构体是没有继承关系的，而类是实现面向对象的基础，结构体只可以简单地理解为类的前身。

## 指针常量与常量指针的区别

指针常量强调指针的不可改变性，常量指针强调指针对其所指对象的不可改变性。

## 如何避免野指针

指针声明时初始化，可以是具体的地址值，也可让它指向NULL。

指针指向的内存空间被释放后指针应该指向NULL。

在变量的作用域结束前释放掉变量的地址空间并且让指针指向NULL，避免超越了变量的作用范围。

## 句柄和指针的区别和联系是什么？

Windows系统用句柄标记系统资源，隐藏系统的信息。只需要知道有这个东西，然后去调用就行，它是个32it的uint。指针则标记某个物理内存地址，两者是不同的概念。

## extern"C"

作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言（而不是C++）的方式进行编译。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名，这样可以区分重载的函数；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。
