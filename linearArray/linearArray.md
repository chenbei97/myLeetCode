<!--
 * @Author: chenbei
 * @Date: 2022-02-23 16:54:57
 * @LastEditTime: 2022-04-12 15:57:06
 * @Description: linearArray.md
 * @FilePath: \myLeetCode\linearArray\linearArray.md
 * @Signature: A boy without dreams
-->
## 解题思路

## 最接近原地的k个点

给定一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点，并且是一个整数 k ，返回离原点 (0,0) 最近的 k 个点。

### sort解法

排序算法sort第三个参数可以指定排序方式，自定义的排序方式可以使用函数对象或者仿函数或者匿名函数。所以这里只需要依据点之间的欧几里得距离作为排序方式即可。C++可以这样写，使用匿名函数即可。

```c++
auto foo = [](const vector<int>& u, const vector<int>& v) {
            return u[0] * u[0] + u[1] * u[1] < v[0] * v[0] + v[1] * v[1];
        }
```

Python指定关键字即可，匿名函数使用lambda表达式即可。

```python
key=lambda x: (x[0] ** 2 + x[1] ** 2) # python不需要比较2个参数,因为提供reverse选项
```

### heap解法

我们可以使用一个大根堆实时维护前k个最小的距离平方。先将前k个点的编号以及对应的距离平方放入大根堆中，随后从第k+1 个点开始遍历：如果当前点的距离平方比堆顶的点的距离平方要小，就把堆顶的点弹出，再插入当前的点。当遍历完成后，所有在大根堆中的点就是前k个距离最小的点。 C++ 语言中，堆（即优先队列）为大根堆，但在 Python 语言中，堆为小根堆，因此我们需要在小根堆中存储（以及比较）距离平方的相反数。

## 每日温度

给定一个整数数组 temperatures ，表示每天的温度，温度范围在 [30, 100] 之内。要求返回一个数组 answer ，其中 answer[i] 是指在第 i 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。

### iteration解法

对于温度列表中的每个元素 temperatures[i]，需要找到最小的下标 j，使得 i < j 且 temperatures[i] < temperatures[j]。由于温度范围在 [30, 100] 之内，因此可以维护一个数组 next 记录每个温度第一次出现的下标。数组 next 中的元素初始化为无穷大，在遍历温度列表的过程中更新 next 的值。

反向遍历温度列表。对于每个元素 temperatures[i]，在数组 next 中找到从 temperatures[i] + 1 到 100 中每个温度第一次出现的下标，将其中的最小下标记为 warmerIndex，找到最小的下标是因为这个是第1次出现的比 temperatures[i]高的温度。如果 warmerIndex 不为无穷大，则 warmerIndex - i 即为下一次温度比当天高的等待天数，最后令 next[temperatures[i]] = i。temperatures[i]是温度，让这个温度值作为索引的那个值为i。因为遍历温度列表的方向是反向，当遍历到元素 temperatures[i] 时，只有 temperatures[i] 后面的元素被访问过，即对于任意 t，当 next[t] 不为无穷大时，一定存在 j 使得 temperatures[j] == t 且 i < j。又由于遍历到温度列表中的每个元素时都会更新数组 next 中的对应温度的元素值，因此对于任意 t，当 next[t] 不为无穷大时，令 j = next[t]，则 j 是满足 temperatures[j] == t 且 i < j 的最小下标。

### stack解法

遍历每日温度，维护一个单调栈，若栈空或者每日温度小于栈顶温度直接入栈；否则如果当日温度大于栈顶温度，计算这个温度和栈顶温度的相差天数。这个温度不会入栈，只会在后面的遍历每日温度时入栈。因为要求的是天数，所以栈元素是温度元素的索引值。

## 颜色分类

给定一个包含红色、白色和蓝色、共 n个元素的数组nums，整数0、1、2分别表示红色、白色和蓝色。原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列，不能使用库的sort函数。

### iteration解法

可以考虑对数组进行两次遍历。在第一次遍历中，我们将数组中所有的0交换到数组的头部。在第二次遍历中，我们将数组中所有的1交换到头部的0之后。此时，所有的2都出现在数组的尾部，这样我们就完成了排序。

### doublePointers解法

使用一次遍历，额外使用一个指针，即使用两个指针分别用来交换0和1。用指针 p0来交换0，p1 来交换1，初始值都为0。当我们从左向右遍历整个数组时：如果找到了 1，那么将其与nums[p1]进行交换，并将 p1++，这和iteration解法类似。 如果找到了0，那么将其与nums[p0]进行交换，并将p0 向后移动一个位置。将0与nums[p0]进行交换，可能会把一个1交换出去。当p0 < p1时，我们已经将一些1连续地放在头部，此时一定会把一个1交换出去，导致答案错误。因此，此时需要再将nums[i]和nums[p1]进行交换，其中i是当前遍历到的位置，在进行了第一次交换后，nums[i]的值为1，我们需要将这个1放到已排序数的末端。在最后，无论是否有 p0 < p1需要将 p0、p1均向后移动一个位置，而不是仅将 p0向后移动一个位置。

## 救生艇

给定数组 people 。people[i]表示第 i 个人的体重 ，船的数量不限，每艘船可以承载的最大重量为 limit。每艘船最多可同时载两人，前提是不超重，求承载所有人所需的最小船数 。

### iteration解法

尽可能的多上人是贪心的思想，由于最多可以上2个人，所以尽可能让最重的和最轻的在一起就可以实现，这一般也是最优解。使用2个指针指向2个人的体重，让体重事先已经有序。这样初始时指针一个指向最轻的，一个指向最重的，然后开始两个指针向中间移动，也就是对撞指针。循环条件是左指针小于等于右指针，所以先判断指针是否重合了。如果重合，这个人直接就一个人上船。如果不重合，考虑这两个人的体重之和，如果超过limit，如果想上船，优先让重的走(贪心)，那么船数量计数+1，让右指针前移；如果没超过limit，那就两人一起走，两个指针同时向中间移动，直到循环结束。

## 接雨水

### iteration解法

对于不同的地面距离(数组的每个数字)，水有多高取决于这个点左侧和右侧墙壁的最大高度。第一个for循环找每个点的左侧最大高度，第二个for循环找每个点右侧的最大高度，循环中跳过最左侧(i=0)和最右侧点(i=vector.size()-1)的原因是这两个点由于没有左侧墙壁或右侧墙壁所以最大墙壁高度肯定是0，故在初始化vector的时候已经将其默认设置成0了。在得到所有点的左右墙壁最大高度后，木桶原理取左右墙壁较低的那个高度减去当前位置墙壁作为地面的高度就得到了这个位置上水的高度。然后将所有点的水高度相加即为解。

其实这个解法很像[除自身以外数组元素的乘积](#除自身以外数组元素的乘积)的做法，代码上具有相似性比较当前元素nums[i]左右两边的所有元素的大小，找到最大的那个高度放入对应的left或者right，之后right[i]和left[i]较小的那个与地面值nums[i]做差得到的就是可装雨水，前提是大于0，因为可装的水不能是负数。

## 找出第K小的距离对

给定一个整数数组，返回所有数对之间的第k 个最小距离。一对 (A, B) 的距离被定义为 A 和 B 之间的绝对差值|A-B|。

分为两部分处理：

第一部分是二分查找，所以要将数组先排序，然后查找的是要求的第k个最小距离。具体的距离是二分来量化的，外部只提供k值，例如k=1是要求找到最小的距离，k=2是第二小的距离。二分距离要求知道最大和最小距离，显然我们可以认为最小距离是0，一个初始值，最大距离就是nums[n-1]-nums[0]。然后二分距离，mid=(left+right)/2，根据这个距离我们要计算一个返回值numOfLessThan Distance()，也就是比这个距离mid小的数据对有几个，它可以和k进行比较。如果它比k小，说明目前的距离mid一定不是第k小，应当让距离大一些，故left=mid+1。同理如果返回值比k大，mid也一定不是第k小，应该让距离小一些，即right-mid-1。

关键：如果返回值等于k，可以说明就是第k小吗，然后直接返回距离mid？如果nums=[1,1,3]，显然有3个组合，距离为[0,2,2]。那么第1次二分mid=1，找到比距离1小的元素组合有几个？显然答案是一个，只有组合(1,1)的距离是0可以，此时返回值是1。假设要找的就是第k=1小(最小)的距离是多少，返回值应该是距离0，但是现在的距离mid其实是1，这是错误的。

所以应当让numOfLessThanDistance(mid)=k时继续比较，让right=mid-1，真正应该返回的是left，直到left>right为止。这个原因就是第二部分计算的其实是小于mid的个数而不是小于等于mid的个数。

第二部分是寻找小于指定距离mid的元素对个数。使用双指针即可，left指针指向0，right指针从0到n-1开始遍历。每个元素对的距离就是nums[right]-nums[left]。我们要找的是这个值比mid小时让计数+1，同时让left指针能够前进避免计算出重复的距离，所以控制条件变为当nums[right]-nums[left]>mid时让left+1，之后计数变量cnt加上小于mid的数量，这个值等于right-left，因为当前的right是比mid大的，所以实际上区间[left,right-1]的是比mid小的且没有重复的元素对，那么个数就是right-1-left+1=right-left。因为闭区间[a,b]的数量是b-a+1。

## 数组交集

给两个整数数组，以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值。可以不考虑输出结果的顺序。例如nums1 = [1,2,2,1], nums2 = [2,2]，那么交集是[2,2]；nums1 = [4,9,5], nums2 = [9,4,9,8,4]，则交集是[4,9]。

### doublePointers解法

事先让2个数组都有序，然后2个指针分别指向两个数组的首元素。循环条件：2个指针都没有越过各自的最后1个元素。先到达的数组往往是它的后几个元素比另一个数组的元素一直小或者一直大，所以指针很快移动到尾端，这样因为有序的原因，另一个数组也不可能再出现能小于等于或大于等于本数组最后一个元素的元素了，此时交集也已经找到。

## 除自身以外数组元素的乘积

### iteration解法

创建两个数组，一个用于记录某元素前元素的乘积，一个用于记录某元素后元素的乘积，最后用两个元素进行逐元素相乘即可。

节省空间的写法，是利用2个数即可，动态的表示为某元素前与后的乘积即可。

## 把数组零元素移动到尾端

如题，要求不能改变其他元素之间以及0元素之间的相对次序，而且是原地移动。

### doublePointers解法

提供一种倾向，遍历数组的每个元素nums[right]，初始时，最前边待交换的元素是nums[left=0]，从nums[right=0]开始到nums[right=n-1]比较是否为0，不为0就弄到前边。如果发生了交换，现在nums[left]是非0元素，而nums[right]可能不是0也可能是0，它可以在之后的某次判断(left到达此时的right时)来决定是否交换，如果是0肯定会被交换到那时的right位置。因为交换发生后，nums[left]一定不会再是0，不能再交换回来，所以下一次交换的是nums[++left]，要让left++。

## 二维数组螺旋遍历

### iteration解法

思路是从外边一圈到次一圈直到最后1圈(在方阵且奇数时只有1个数)，关键就是获取每个圈的4个顶点坐标。因为每圈遍历总是符合这样的遍历过程：[top,left]->[top,right]->[top+1,right]->[bottom,right]->[bottom,right-1]->[bottom,left]->[bottom-1,left]->[top,left]，即top行->right列->bottom行->left列。另外如果不是方阵，会存在top=bottom但是left≠right的情况(反过来也是)，这样最后一圈遍历完top行和right列以后就可以结束，不要再遍历bottom行和left列造成重复，所以要添加一个条件，只有都不相等时才会遍历bottom行和left列。

## 找到数组的最大和最小值

### iteration解法

用两个变量记录目前最大和最小的值索引，根据数组大小n的情况来决定返回。

如果n=0，什么都没有；n=1，则最大和最小索引都是0；

如果n>1，还要判断n的奇偶性，如果是奇数，则初始最大最小值索引都从0开始，循环起始点为1；如果是偶数，就先比较a[0]和a[1]的情况，然后大的那个索引为maxIndex，小的给minIndex，循环起始点为2；这样可以保证后边的元素总是两两成对，便于比较；

开始每2个元素一组进行比较，大的那个元素和a[maxIndex]去比较，小的那个元素和a[minIndex]去比较，必要的话更新maxIndex和minIndex的值，循环结束就可以得到结果。

### recursion解法

借助分而治之的思想，这个解法是反复二分数组，直到最小单元2个或1个元素的数组，也就是当n不等于2的时候就会持续下去。如果是2个元素，用2个变量分别记录更小和更大的元素；如果是1个元素，最小和最大都是1个元素。

如果首次进入，n为0就返回2个None；如果是再次进入的，因为二分后数组的奇偶性可能发生变化，所以数组长度可能是1，则最大最小值认为是a[0]，数组调整长度为a[1:]就是[]了，这时候应当直接返回最大最小值；同理，数组长度可能是2，则最大最小值为{a[0],a[1]}或{a[1],a[0]}，调整数组的长度为a[2:]也是[]，应当直接返回，这是递归真正的终止条件。

例如，先判断n不为0以后，假设a还有2个或3个元素。此时再判断a是否等于2，如果等于2，二分后就是2个包含1个元素的数组；如果等于3，1个数组1个元素，另1个数组2个元素。然后再次进入递归，就遇见上一段所说的递归终止条件，无论是1个元素还是2个元素都会直接返回，不会再递归入栈，会不断递归退栈。

这个方法的缺点是不知道索引最大最小值在数组的位置，因为数组每次二分这个索引值就不再是原来整个数组的真实索引值了，只是各自小数组的索引位置。如果想通过这一系列小数组的索引位置倒退原数组真实的索引位置，比较困难。

另外递归法的速度甚至慢于纯循环方法，更不比说上边优化过的循环方法，代码文件测试，10000000个元素的量级下，递归花费7.16s，纯循环花费4.9s，上述优化的循环方法花费3.77s。

### stack解法(最小栈问题)

构建2个栈，一个栈负责存放push数组的所有元素，一个栈只记录最小的元素。

第2个栈初始存放的是无穷大元素，然后每次push时，都会比较栈的top元素和值val，小的入栈，初始的时候是val<inf。

然后再看pop操作，第一个栈直接pop没问题，第2个栈也要pop，因为第2个栈存放的是与第一个栈拥有的元素对应的最小元素。

top操作，直接返回栈的top即可。

获取最小值，只需要获取第2个栈的栈顶元素即可。

## 两数之和

找到2个数等于指定的数，返回这两个数的索引。

### iteration解法

C++中可以使用双while循环使用迭代器遍历也可以使用双for循环遍历，前者速度更快一些168ms左右，后者304ms。

思想是从第1个数开始，暴力匹配剩余的数，如果两数之和满足则返回索引，否则从第2个数暴力匹配剩余的数，直到最后2个数。

如果到了最后1个数，直接返回{-1,-1}。

对于Python直接使用列表双for循环即可，大约2900ms。

时间复杂度：O(n^2），空间复杂度：O(1）

### hashTable解法

哈希表是一个带有关键字的表，类似于字典，存在关键字-值的映射关系。这样查找1个元素无需比较，那么两数之和问题就可以变为对于1个元素a，表中是否存在target-a的元素，如果有返回这个元素的关键字。且由于两数之和问题，有个假设条件，就是两个数是不相等的，例如对于8而言，假如nums有3、4、5，应当返回3、5的索引而不是2个4的索引。

那么只需要实现把数组的索引和值存入哈希表，需要1次循环存入数值对；然后再次遍历每个数组元素a[i]，考量表中是否存在target-a[i]，且返回的索引不能是i。

哈希表的速度很快，C++只有12ms，Python中哈希表就是字典，为32ms。

## 三数之和

给定数组找到所有3个数和为0的三元组。

因为给定的数组元素可以有重复的，所以元素值不能作为标签，所以也就不能利用两数之和的解法来找。

### iteration解法

将数组进行从小到大排序，然后在三重循环中得到的三元数组(a,b,c)总是可以保证a≤b≤c，但是即使如此也不能保证所有重复的三元组被去掉。因为同一重循环，相邻的两个元素重复就会造成三元组重复，为了避免这个问题，还要加限制条件，即后1个元素要大于前1个元素。

### doublePointers解法

这个解法相对于上述解法进行了优化，因为在a固定时，如果b比较大，那么c应当比较小才可能和为0，根据这个可以进一步去除不必要的循环。那么可以在第2重循环的基础上，定义指针c，c指向数组的右端，随着b的取值不同，找到1个合适的c，这样的c在a+b+c＞0时肯定是不存在的，所以可以让循环条件为a+b+c>0，否则c持续向左移动，这时再遍历b和c之间可能的元素，减少了一些不必要的迭代，不过也要注意c持续向左移动也不能小于b，但是c是可以退到b的，此时说明不会再有合适的c，就没必要再继续，因为当前的b不成立，下一次b只会更大，但c又是b后面的位置，所以c更大，那么永远不可能遇见合适的c，故2重循环使用的是break而不是continue。

C++实现88 ms，Python为768ms。

## 最接近的三数之和

给一个长度为n的数组nums和 目标值target，从nums中选出三个整数，使它们的和与target最接近并返回这三个数的和。

假设条件：输入数组只存在恰好一个解，不能重复使用1个元素作为答案。

### iteration解法

也是暴力匹配法，三重循环跳过重复值后，剩下的三元组求和并与target做差得到差值，如果等于0直接返回target，如果不等于0，这个差值再与ans与target的绝对值差进行比较，如果前者的差值更小也就是更接近target，就更新ans为当前三元组的元素和，ans一开始是一个较大的值。

### doublePointers解法

第1重循环跳过重复的值后，设定两个指针分别指向i+1和n-1，这是因为数组已经有序，固定a的情况下，根据b和c的动态变化可以跳过一部分循环。现在b=nums[i+1]，c=nums[n-1]，如果运气不错，a+b+c=target，就直接返回了；如果运气不好，就要比较abs(a+b+c-target)和abs(ans-target)，如果前者小说明更接近就更新target为a+b+c；更新完后，考虑b、c如何移动的问题，取决于a+b+c-target是>0还是<0；如果是>0，说明b已经有点大了，只能向左移动c，才会让c变小，从而减小差值接近0；如果是<0，说明b有点不够大，向右移动b增大差值就可以更接近0；这个过程发安抚更新ans的值，直到j>=k意味着结束，因为j=k是取了相同的元素，与假设条件不符。

## 四数之和

### doublePointers解法

结合了两数之和和三数之和的做法。首先固定第1个数和第2个数，如果有重复的就跳过元素，只需要注意好范围即可。第1个元素first是从0开始的，但是为了和前一个元素判断是否相等，所以实际上是从位置1开始的，然后要求first+3<=len(nums)-1，这样可以计算出first最多取到n-4，所以在for循环中使用<n-3正确。同理第2个元素second，也是要求second要大于first+1，同时<n-2。

之后的2个元素使用双指针法处理，比目标值大前移fourth指针，反之后移third指针。如果相等就把这些元素加入答案列表，然后，要接着前移fourth和后移third，因为可能会重复的所以也要跳过，让third和third+1比较，相等的话后移，fourth和fourth-1比较，相等的话前移。

## 删除有序数组的重复项

原地删除重复出现的元素，并返回删除后数组的新长度，不能使用额外的数组空间，不需要考虑数组中超出新长度后面的元素，给定的数组是有序的。

### doublePointers解法

如果数组元素个数为0，就返回0；不为0，至少有1个元素，定义2个指针都指向数组的位置1。因为数组是有序的，重复的元素必定是连续的，那么判断当前元素和前一个元素是否相等即可。如果不相等说明不是重复的，那么就把快指针的值给慢指针，慢指针向前移动，然后再移动快指针；如果相等就不必移动慢指针，只需要移动快指针，直到快指针超过数组尾元素的位置即可结束循环，此时返回slow的位置就是新数组的长度。

## 移除指定元素

移除所有数值等于val的元素，并返回移除后数组的新长度。要求不使用额外的数组空间，元素的顺序可以改变，也不需要考虑数组中超出新长度后面的元素。

### doublePointers解法

类似于删除有序数组的重复项，区别在于双指针从0开始，当快指针没到数组尾部元素之外时，如果发现快指针指向的元素等于了指定值，就跳过，让快指针继续增加；如果不相等，说明不是指定值，就让慢指针等于快指针指向对的值，然后移动慢指针，快指针也移动。

## 合并两个有序数组

### iteration解法

直接合并两个数组即可，把第2个数组接在第1个数组后边，然后利用排序算法直接排序即可。

### doublePointers解法

定义2个指针，开始都指向2个有序数组的位置0处。大while循环，只要2个有一个没有到达对应数组的末尾位置，就执行循环。然后开始比较2个指针指向的元素，小的那个被添加进答案，然后指针+1，另一个不动。然后需要可考虑指针到达末尾位置的时候，另一个指针无需再移动，把另一个数组剩下的元素全部添加进去即可。

## 搜索旋转数组指定数

给定一个实现旋转过的有序数组，可以保证数组元素不相同。

例如[1,2,3,4,5,6,7]在loc=3的位置旋转就变成[4,5,6,7,1,2,3]

要求找到给定目标的索引位置，不存在的话返回-1

### binarySearch解法

对于有序数组，可以使用二分查找的方法查找元素，因为旋转后的2个小部分是有序的。每次二分时可以依据，arr[mid]和arr[0]的大小关系，以及target和arr[mid]的关系来缩小范围。

假如满足arr[0]<=arr[mid]，这说明在[0,mid]之间是有序的。且target<arr[mid]的话就可以缩小二分范围，调整right为mid-1，新的二分范围是[0,mid-1]，当然如果恰好arr[mid]=target时就会直接返回，也可能target>arr[mid]，那么说明target不在这个有序范围内，在另一个区间，所以调整left为mid+1。

还有一种情况，arr[0]>arr[mid]，这说明mid处于右侧区间，[mid+1,n-1]是有序的。且target>arr[mid+1]的话就可以缩小二分范围，调整left为mid+1，新的二分范围是[mid+1,n-1]；如果target<arr[mid+1]，说明target在左侧区间，调整right为mid-1，新的二分范围是[0,mid-1]。

## 判读是否2的幂

### iteration解法

从x=0开始，如果2^x小于target，就让x增1，等于直接返回true，大于就返回false

### recursion解法

递归函数，输入x，返回x+1，直到2^x大于target，就停止

### bit解法

一个满足2的幂的数，它用二进制数表示只有最高位有1个1，其它全为0。

一个普通的数，从高位开始有a个1，后边可能都是0(偶数)，也可能有1个1(奇数)。

符合2的幂的数减去1，就是高位借给1变为0，低位都+1，如数字8用1000表示，7则用0111表示。

这样的数字进行与运算，发现恰好就是0，也就是一个符合2的幂的数，它应当满足n和n-1的与运算是0，不是的话就不是2的幂数。

不过这个条件要求n>0，n=0也满足，但不是2的幂数

或者利用-n的相反数，它的二进制编码是n的补码，补码为原码取反再加+1，如1000取反是0111，再加1为1000，两者与运算为1000还是n，即n&(-n)为n的数才是2的幂数

## 找出只出现一次的数字

数组只有1个元素出现1次，其它元素都出现3次，找出这个数字。

### hashTable解法

可以使用哈希映射统计数组中每个元素的出现次数，键表示一个元素，值表示其出现的次数。

### bit解法

除了答案，其它的数字都出现了三次，这也意味着它们转为二进制数后对应的位置也都出现了3次。而二进制数只有0和1，把同一个数对应位的数字相加应当为0或者3，也就是3的倍数。

当然是无法事先知道加的3个数就是相同的，所以考虑所有数的和，那二进制的情况下，除了答案以外，对应位之和依然是0或者3的倍数，那么答案的对应位应该是所有数对应位加起来之和除3的余数，非0即1，所以这样可以确定答案该位是0还是1。所有位都过一遍，就可以知道这个数字的所有二进制位，也就得到了这个数字。

需要注意的是，如果使用的语言对有符号整数类型和无符号整数类型没有区分，那么可能会得到错误的答案。有符号整数类型的第31位是补码意义下的符号位，也就是-2^31，只有无符号整数才是2^31。python对此没有区分，所以对最高位的判断需要特殊处理。

计算每个数的位大小需要位运算。

有符号左移运算<<，例如左移2位，先把一个数转为32位二进制数，把高位舍弃2个0，在地位补2个0，如11左移2位就是1100。

在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以2的1次方，左移n位就相当于乘以2的n次方。

有符号右移运算>>，例如右移2位，也是先转为32位二进制数，低位的2个数舍弃，高位因为是整数所以补2个0，例如1101变为11。

右移一位相当于除2，右移n位相当于除以2的n次方。

根据2进制位得到10进制数，只需要在每个位总数对3的余数为1时，让ans扩大2倍，也就是和1>>i进行或等运算，对于python在i为31时最高位需要减等运算。

## 找出数组的所有子集

数组内可以保证所有数字不重复，找出素有子集，包括空集合。

### iteration解法

由于数组内的数字不重复，而这个数字只有在集合和不在集合的状态，也就是0或者1。那么n个数字，就可以用n位二进制数去描述，每一位代表每一个数字是否在集合的状态，因为存在全1或者全0，所以集合本身和空集合都不会被漏掉。

n个数字有2^n个可能，可以用(1<<n)来表示，遍历每个可能，就找到了所有集合。每个可能是一组二进制数，还要把它映射为10进制数，也就是原数组的索引。例如数组有3位数字，一共有8种可能，000到111，对于某个可能mask如101，它的含义是第1和第3个数字在集合中，然后用临时变量存储第1和3个数字。如何找到101对应的数字1和3呢？检测101就是要从地位到高位去检测，检测低位用101和1相与，检测高位就是用100相与，所以轮流检测101的每个位，就是让(1<<0)到(1<<n-1)依次和101相与，写成循环就是for(int i=0;i<n;i++) mask&(1<<i)，例如mask为101的时候，101依次与1，10，100，位运算不为0的就说明这个位置的元素在集合中。

### recursion解法

递归法就是从数组的第1个数字开始，一直到最后1个数字，轮流确定每个数字的状态，0或1，也就是在集合中或者不在集合中。进入递归前，当前数字cur已经被确定，可以是加入集合，被添加到t，也可以不加入集合，已经添加的再pop即可，也进入递归。第1次递归尽头是全部数字都在集合，这个集合被添加进答案后准备开始回溯，也就是不添加cur时也是一个集合。由此从序列1个元素不缺，到缺1个元素再到缺2个元素，如此重复回溯，直到最后，t里边没有元素了，空集合也会被添加进ans，递归结束。

个人感觉在这还是有些不好想象的，姑且记住吧。

## 数组平方

给一个升序数组，可能有负数，返回平方后的数组，要求也是升序。

### iteration解法

平方后，再重排，最简单的方法。

### doublePointers解法

上边的方法没有利用，nums已经按照升序排列。找到负数与整数的分界线neg，那么[0,neg]均为负数，[neg+1,n-1]是正数。这样可以得到2个有序的数组，那么就可以使用归并操作。首先2个指针分别指向负数的最大值neg和整数的最小值neg+1，比较它们的绝对值，更小的放在前边，然后对应的指针+1或者-1，直到指针到达n-1或者0结束，如果有一个指针先到达，剩下的肯定是最大的。

## 数组的相对排序

arr1和arr2，arr2的元素互不相同，arr2的元素在arr1中都有，且arr1可以有多个相同的arr2中的元素。要求按照arr2的相对次序，对arr1中所有arr2有的元素进行排序，如果arr2没有这个元素就按照升序添加到arr1的末尾。

### hashTable解法

由于arr2规定了次序，例如arr2=[2,1,4,3,9,6]，因为元素不重复，可以遍历arr2，值作为哈希表的键，索引为哈希表的值，可以实现一组映射。然后每2个元素x,y进行依次比较，如果2个数在哈希表的关键字里，那就比较它们哈希表的值，如果map[x]>map[y]，就交换x和y；如果2个数均不在哈希表字典里，比较本身即可，x>y也进行交换；其它情况，由于要求不在arr2出现的数放在后边，所以如果x出现在哈希表，它应该是放在前边的，所以不用交换x,y，反之是y出现在哈希表就要交换。

写法上和冒泡排序一样，首先x是第1个元素，y是x后边的每一个元素，都和x相比，必要的话进行交换。然后再移动x，如此往复。

### iteration解法

因为输入的元素范围是有限的，在[0,1000]内，所以可以考虑是用一个数组记录所有出现的元素出现的次数，所以要求这个数组的大小为1001。不过可以继续优化一下空间，找到arr1最大的数即可，然后给数组分配这个数+1的空间即可。

然后遍历arr1的每个元素，记录出现的次数。然后再遍历arr2的每个元素，因为保证arr2的元素都会出现在arr1，所以这个元素在arr1出现几次，答案就添加几次，这样在arr1中，arr2出现的元素都已经按照原本的次序有序，同时将已经排过序的技术数组对应位置请0，用于后续使用。还剩下arr2未出现的元素，还需要对记录个数的数组进行遍历，在不为0次的情况下，只剩下arr2未出现的元素了，而且顺序遍历的情况下，已经是升序状态，添加进答案的这些元素是升序的。

## 数组多数元素

给定一个大小为 n的数组，找到其中的多数元素，多数元素是指在数组中出现次数大于n/2的元素。可以假设数组是非空的，并且给定的数组总是存在多数元素。

### hashTable解法

把每个数字作为键，出现1次值就增加1，最后比较值最大的那个键就是多数元素。

### sort解法

因为保证众数元素的数量超过一半，所以众数一定在排序后的中间位置。

## 最大子数组和

找到一个连续的部分，至少包含1个元素，使它具有最大和

这个题可以参考找到数组的所有子集，然后删除非连续的子集，再统计最大的和，不过这么一套操作比较复杂。

### dynamicProgramming解法

动态规划的思想，不过暂时看不懂，先跳过

解法：使用一个数组f存储一些数，用 f(i) 代表以第 i 个数结尾的连续子数组的最大和，求出每个位置的 f(i)，然后返回 f 数组中的最大值即可。可以考虑 nums[i] 单独成为一段还是加入 f(i−1) 对应的那一段，取决于 nums[i] 和 f(i−1)+nums[i] 的大小。所以存在一个动态规划方程：f(i) = max(f(i-1)+nuns[i],nums[i])。考虑到 f(i) 只和 f(i−1) 相关，于是我们可以只用一个变量 pre 来维护对于当前 f(i) 的 f(i−1) 的值是多少，空间复杂度降低到 O(1)。

### iteration解法

这是自己给出的解法。

依次遍历每个元素，把他当作连续子数组的末尾元素，从末尾开始向前，只要合并一个元素就添加进答案，这样，所有的可能都被添加进答案。然后计算答案最大的元素，这个方法好处在于也可以得到连续的最小子数组和。

## 找到指定距离的重复元素

给定一个数组，一个指定数k，如果存在nums[i]<nums[j]且|i-j|<k就返回true，否则返回false

### hashTable解法

遍历数组每个元素，用哈希表记录每个元素的下标，如果遍历过程遇到重复的元素，就更新记录的下标，保证哈希表总是记录元素的最大下标。每个元素遍历的时候都会判断哈希表是否存在该元素为键，如果没有直接加入哈希表，如果有说明当前元素之前有一个元素和他重复，比较当前索引和现在哈希表以这个元素为键的值，如果绝对值差小于k，就直接返回，否则就更新哈希表键的值。然后遍历下一个元素，直到运行结束，没有返回true就默认返回false。

为什么总是比较下一个重复元素和上一个重复元素的索引呢？如果最近的2个重复元素都不满足索引<k，其它一定不满足。

### hashSet解法

另一个方法是借助滑动窗口+哈希集合。

考虑数组 nums 中的每个长度不超过 k+1 的滑动窗口，同一个滑动窗口中的任意两个下标差的绝对值不超过 k。如果存在一个滑动窗口，其中有重复元素，则存在两个不同的下标 i 和 j 满足 nums[i]=nums[j] 且 |i−j|≤k。如果所有滑动窗口中都没有重复元素，则不存在符合要求的下标。因此，只要遍历每个滑动窗口，判断滑动窗口中是否有重复元素即可。

如果一个滑动窗口的结束下标是 i，则该滑动窗口的开始下标是 max(0,i−k)。可以使用哈希集合存储滑动窗口中的元素。从左到右遍历数组 nums，当遍历到下标 i 时，具体操作如下：

1. 如果 i>k，则下标 i−k−1 处的元素被移出滑动窗口，因此将 nums[i−k−1] 从哈希集合中删除；
2. 判断 nums[i] 是否在哈希集合中，如果在哈希集合中则在同一个滑动窗口中有重复元素，返回 true，如果不在哈希集合中则将其加入哈希集合。

当遍历结束时，如果所有滑动窗口中都没有重复元素，返回 false。

## 有效数独

有效的数独满足以下三个条件：

同一个数字在每一行只能出现一次；

同一个数字在每一列只能出现一次；

同一个数字在每一个小九宫格只能出现一次。

数字只在1-9范围内，数独就9×9的。

### iteration解法

使用3个数组来分别记录每行、每列、每个3×3的子宫格内出现的数字个数，原始的宫格记为board。

第1个数组rows，为9×9，第1个9表示是有9行，每1行都要统计，第2个9是因为数字在[1,9]范围，所以数组有9个位置来记录这些数。例如如果第1行有2、3、5出现了，那么rows[1,1]、rows[1,2]和rows[1,4]就会分别+1。

第2个数组col是也是9×9，含义相同，第1个9表示9列需要统计，第2个9是数字在[1,9]范围。

rows和cols实质上都是用1行记录1-9出现的次数，这与board的行列数可以对应。例如，board[7,8]出现的数字是5，那么rows[7] [4]就会+1，表示第7行数字5的位置多了1个，同时cols[8] [4]也+1，因为5也在board的第8列位置，但是cols还是用1行记录的，所以cols的行号其实记录的是board的列号，同样数字5表示第4个位置+1。

第3个数组subBoxes，为3×3×9，生成了一个立方体，这个9表示数字在[1,9]范围，每个子宫格是3×3的，一共9个子宫格，分别用来记录9个数在子宫格位置的出现次数。例如数字5，在第4个子宫格记录，也就是subBoces[ ] [ ] [4]，而子宫格的每个格子来记录board的9个子宫格在数字5上如何出现的。board的9个子宫格分界线与坐标i、j有关，坐标都除3，就可以把board的原坐标分成9个小区域，即把board[i] [j]映射到subBoxes[i/3] [j/3] [num]，这里num=board[i] [j]-1。例如board[0] [0] = 5，那么subBoxes[0] [0] [4]就会+1，假如有重复，board[1] [1] = 5，那么subBoxes[0] [0] [4]继续+1，注意这里是除法，所以[0-2] [0-2]内除3就对应[0] [0]。而subBoxes[0] [1]，到subBoxes[2] [2]依次记录board的后面8个子宫格。

## 买卖股票的最佳时机I

给定一个数组，元素的含义是每一天的价格，从某天算起，后面的某一天卖出，找到最大的利润。

### iteration1解法

暴力法，就是每个元素开始总是和后面所有元素做差，大于0的和当前的最大利润作比较，如果有更大的利润就更新，没有就不更新，初始最大利润为0，小于0的不变。这种迭代方式需要2个for循环，执行n(n-1)/2次。

### iteration2解法

其实找到历史最低点即可，然后之后的每一天都可以和这个最低点比较，记录差值，结束后就得到了最大利润。

定义初始最低点价格为无穷大，初始最大利润0。然后遍历每个价格，首先先和最低点比价格，如果更低就可以更新最低点价格，再计算当前价格和历史最低点的差值，如果大于了历史最大利润就更新最大利润。如果最低点没有更新，就直接计算价格和历史最低点价格即可。

## 买卖股票的最佳时机II

和上一道题的区别是，第一道题是找到何时买入，何时卖出的利润最大，也就是在最低点后的最高点与最低点之差。

这道题是，买入以后如果想再次买入必须先出售之前的，也可以当天买当天卖，如果买入的话找到这种情况利润最大的时刻。所以可能前后价格之差有小于0的情况，这就是亏本，怎么让亏本和赚钱综合最大，是这题的目的。

### dynamicProgramming解法

因为不能同时多个交易，买完了必须卖出才能再买，那么就可以考虑手上的股票数，可以没有股票，也可以最多1只股票。

定义状态 dp[i] [0]表示第 i 天交易完后手里没有股票的最大利润，可能是前一天一个股票今天卖出导致的，也可以是前一天没有股票了。初始第0天，dp[0] [0]=0，没有买股票此时利润为0，如果买了股票，花费是prices[0]，所以利润是-prices[0]。从第1天开始，后1天没有股票的利润怎么计算呢，根据上边的说明是，可以是前一天就没有股票，也就是dp[i - 1] [0]，那今天也无法交易。也可以是前一天有股票的情况，今天可以交易，交易的价格是prices[i]，所以利润是dp[i - 1] [1] + prices[i]，这两个值取最大的就是今天没有股票情况时的最好利润。

 dp[i] [0] = max(dp[i - 1] [0], dp[i - 1] [1] + prices[i])

如果今天是有股票呢，那么说明前一天有个股票但是没卖，这时利润不变；也可能是前一天没股票但是今天买了1个股票，这时利润要减去成本prices[i]。

dp[i] [1] = max(dp[i - 1] [1], dp[i - 1] [0] - prices[i])

最后第n天时手上必定是没有股票时利润最大，也就是dp[n] [0]，这里n是prices的长度减去1

### Greedy解法

由于股票的购买没有限制，因此整个问题等价于寻找 x 个不相交的区间，使得Σ(i=[1,x])(a[ri]-a[li])最大，其中ri表示第i天卖出，li表示第i天买入，买入的这一天不作为区间元素。将所有可能的卖出和买入都计算一遍，找到其中和的最大值就是答案。

因为区间(li,ri]是可以分成一个个长度为1的小区间的，也就是从(li,li+1)到[ri-1,ri]这些区间，因此问题可以简化为找 x 个长度为 1 的区间 (li,li+1] 使得Σ(i=[1,x])(a[li+1]-a[li])的和最大，即用1个变量就可以表示。贪心的角度考虑我们每次选择贡献大于 0 的区间即能使得答案最大化，因此最后答案为ans=∑(i=[1,n−1])max(0,a[i]−a[i−1])。

这个答案通俗点说，只要第2天相比于前1天买入的成本卖有的赚就可以卖，否则就不卖。虽然直觉上这样做不一定就能最大化，但是这道题确实可以证明这种直觉是对的，同时贪心算法只能用于计算最大利润，计算的过程并不是实际的交易过程。



