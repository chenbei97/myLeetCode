## 合并两个有序链表

### recursion解法

每次比较的共同的点是：如果第1个链表的节点是空，就返回第2个链表的节点；如果第2个链表的节点是空，就返回第1个链表的节点；如果均不为空，那么应当更新某个链表节点的next指向。如果第1个链表节点的值小于第2个链表节点的值，说明以第1个节点为基础即可，然后更新第1个节点的next，而这个next的值取决于第1个节点next的值和第2个节点的值熟大熟小。当然也可以是第2个链表节点的值比较大，那就用第2个节点的next和第1个节点去比较，来更新第2个节点的next。

这样反复递归下去，直到最后有1个链表节点是空的，就开始执行退栈过程，这个空节点作为上个节点的next，上个节点又作为上上个节点的next，一路退到最后，就是真正的list1或者list2了。

### iteration解法

我自己的解法：

首先判断均为空的情况，直接返回空指针；只要不均为空，就可以循环，所以while的条件是list1为空或者list2为空。先设定1个指针t，已经初始化过，指向某个地址，然后再用ans记录这个地址，之后更新的是t->next，ans记录的是最初的t，t更新为t->next不会影响ans。

然后先考虑均不为空的情况，那么就可以比较2个值，比较之后，让t的值等于更小的那个值，然后更新t为t->next，同时也更新那个更小的list1或list2为其next。这个操作的前提是，t在更新为t->next之前，要先给t->next新建new1个节点，否则t更新完是空指针，下次再比较就会出问题。如果2个值相等，只需要让t和t->next的值都等于这个值，然后同理t更新到t->next->next之前都要事先new出个节点，再去更新list1和list2指向自己的下一个节点。但是这样可能会导致，list1和list2更新完后while直接退出。t多new了个节点，默认的值为0，所以还要加个判断条件，如果更新完后list1和list2都为空，先把new出来的t->next->next置为nullptr，再退出while，再返回ans；

如果2个节点有1个为空，直接让t的值等于非空节点的值，让t->next和非空节点的next相等接上即可，因为链表已经有序，直接退出循环。

官方解法：

前边是比较类似的程序，先设定t=new的节点，再让ans等于这个节点记录最初的t地址，但是这个节点当作是第1个节点的前1个节点。然后思路是，两个节点均不为空作为while条件，然后去比较2个节点的值，然后更新t的next为list1或list2的next；while结束以后至多有1个节点不为空，因为已经有序，让t直接接上非空节点即可。

## 找出链表相交节点

### doublePointers解法

两个链表均不为空时才可能相交，如果有一个为空直接返回nullptr。

均不为空时，定义指向两个链表头节点的指针pa和pb，如果pa不为空就移动pa到下一个节点，pb也是如此；直到某个指针遇到了空节点，例如pa遇见空节点，则让它重新指向b链表的头节点，然后一样pa不为空就更新，pb也是如此遇到空节点会指向a链表的头节点；直到pa和pb都指向同1个节点或者都指向空节点，就返回同一节点的地址或者mullptr。

找出相交节点的问题，大类上考虑2种情况，即测试案例是相交的和不相交的。

首先考虑2个链表确实有相交节点，如果2个链表的非相交节点个数是相同的，因为相交节点也是相同的，那么相交节点之间的那些非相交节点个数必定是相同的，那么一开始两个指针会同时到达相交节点，直接返回了；

如果2个链表非相交节点个数不同，也就是相交节点之前的那些节点个数不同，那么就不会同时到达相交节点，两个指针各自到达空节点后就会移动到对方的头节点身上。那么一开始指向较短链表头节点的指针，先到达空节点，然后移动到较长链表的头节点，再到相交节点，走过的路径为短链表的长度+长链表相交节点之前的节点；一开始指向较长链表头节点的指针，后到达空节点，再跳到较短链表的头节点，走过的路径为长链表的长度+短链表相交节点之前的节点；其实这两个路径是相同的，即两个指针会在第一次错过同时到达相交节点后，再次会同时到达相交节点。

如果2个链表每月相交节点，也就会同时到达空节点，返回nullptr。

### hashSet/hashTable解法

把链表A的所有节点地址用一个哈希集合或哈希表存起来，因为每个节点的地址是唯一的，所以哈希表或集合中所有地址是唯一的，链表B和链表A相同的那个地址存在说明相交，返回即可。

注：用哈希表其实也是可以的，因为存储的是节点地址，唯一就正确，只是时间变慢需要156ms，而哈希集合只需要80ms，双指针法更快，40ms。

set和map是不同的，<unordered_set> 和 <unordered_map>也是不同的。

① map和unordered_map的区别

 unordered_map存储机制是哈希表，不会根据key的大小进行排序，存储时根据key的hash值判断元素是否相同，内部元素是无序的。调用count函数返回被查找的元素个数只能是0或者1，unordered_map可类比于Python中的字典dict。

map中的元素是按照二叉搜索树(红黑树)存储，是有序的，在红黑树上查找的时间复杂度是O(logN)，相对于unordered_map的查询速度有所下降，但额外空间开销减小，map进行中序遍历会得到有序遍历。

如果需要内部元素自动排序，使用map，不需要排序使用unordered_map。

②set和unordered_set的区别

unordered_set基于哈希表，是无序的，unordered_set可类比于Python中的集合set。

set实现了红黑树的平衡二叉检索树的数据结构，插入元素时，它会自动调整二叉树的排列，把元素放到适当的位置，以保证每个子树根节点键值大于左子树所有节点的键值，小于右子树所有节点的键值；另外，还得保证根节点左子树的高度与右子树高度相等。平衡二叉检索树使用中序遍历算法，检索效率高于vector、deque和list等容器，另外使用中序遍历可将键值按照从小到大遍历出来。

③unordered_map和unordered_set的区别

set没有键值，本身就是键值。









