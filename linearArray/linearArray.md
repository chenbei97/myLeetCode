## 解题思路

## 找到数组的最大和最小值

### iteration解法

用两个变量记录目前最大和最小的值索引，根据数组大小n的情况来决定返回。

如果n=0，什么都没有；n=1，则最大和最小索引都是0；

如果n>1，还要判断n的奇偶性，如果是奇数，则初始最大最小值索引都从0开始，循环起始点为1；如果是偶数，就先比较a[0]和a[1]的情况，然后大的那个索引为maxIndex，小的给minIndex，循环起始点为2；这样可以保证后边的元素总是两两成对，便于比较；

开始每2个元素一组进行比较，大的那个元素和a[maxIndex]去比较，小的那个元素和a[minIndex]去比较，必要的话更新maxIndex和minIndex的值，循环结束就可以得到结果。

### recursion解法

借助分而治之的思想，这个解法是反复二分数组，直到最小单元2个或1个元素的数组，也就是当n不等于2的时候就会持续下去。如果是2个元素，用2个变量分别记录更小和更大的元素；如果是1个元素，最小和最大都是1个元素。

如果首次进入，n为0就返回2个None；如果是再次进入的，因为二分后数组的奇偶性可能发生变化，所以数组长度可能是1，则最大最小值认为是a[0]，数组调整长度为a[1:]就是[]了，这时候应当直接返回最大最小值；同理，数组长度可能是2，则最大最小值为{a[0],a[1]}或{a[1],a[0]}，调整数组的长度为a[2:]也是[]，应当直接返回，这是递归真正的终止条件。

例如，先判断n不为0以后，假设a还有2个或3个元素。此时再判断a是否等于2，如果等于2，二分后就是2个包含1个元素的数组；如果等于3，1个数组1个元素，另1个数组2个元素。然后再次进入递归，就遇见上一段所说的递归终止条件，无论是1个元素还是2个元素都会直接返回，不会再递归入栈，会不断递归退栈。

这个方法的缺点是不知道索引最大最小值在数组的位置，因为数组每次二分这个索引值就不再是原来整个数组的真实索引值了，只是各自小数组的索引位置。如果想通过这一系列小数组的索引位置倒退原数组真实的索引位置，比较困难。

另外递归法的速度甚至慢于纯循环方法，更不比说上边优化过的循环方法，代码文件测试，10000000个元素的量级下，递归花费7.16s，纯循环花费4.9s，上述优化的循环方法花费3.77s。

## 两数之和

找到2个数等于指定的数，返回这两个数的索引。

### iteration解法

C++中可以使用双while循环使用迭代器遍历也可以使用双for循环遍历，前者速度更快一些168ms左右，后者304ms。

思想是从第1个数开始，暴力匹配剩余的数，如果两数之和满足则返回索引，否则从第2个数暴力匹配剩余的数，直到最后2个数。

如果到了最后1个数，直接返回{-1,-1}。

对于Python直接使用列表双for循环即可，大约2900ms。

时间复杂度：O(n^2），空间复杂度：O(1）

### hashTable解法

哈希表是一个带有关键字的表，类似于字典，存在关键字-值的映射关系。这样查找1个元素无需比较，那么两数之和问题就可以变为对于1个元素a，表中是否存在target-a的元素，如果有返回这个元素的关键字。且由于两数之和问题，有个假设条件，就是两个数是不相等的，例如对于8而言，假如nums有3、4、5，应当返回3、5的索引而不是2个4的索引。

那么只需要实现把数组的索引和值存入哈希表，需要1次循环存入数值对；然后再次遍历每个数组元素a[i]，考量表中是否存在target-a[i]，且返回的索引不能是i。

哈希表的速度很快，C++只有12ms，Python中哈希表就是字典，为32ms。

## 三数之和

给定数组找到所有3个数和为0的三元组。

因为给定的数组元素可以有重复的，所以元素值不能作为标签，所以也就不能利用两数之和的解法来找。

### iteration解法

将数组进行从小到大排序，然后在三重循环中得到的三元数组(a,b,c)总是可以保证a≤b≤c，但是即使如此也不能保证所有重复的三元组被去掉。因为同一重循环，相邻的两个元素重复就会造成三元组重复，为了避免这个问题，还要加限制条件，即后1个元素要大于前1个元素。

### doublePointers解法

这个解法相对于上述解法进行了优化，因为在a固定时，如果b比较大，那么c应当比较小才可能和为0，根据这个可以进一步去除不必要的循环。那么可以在第2重循环的基础上，定义指针c，c指向数组的右端，随着b的取值不同，找到1个合适的c，这样的c在a+b+c＞0时肯定是不存在的，所以可以让循环条件为a+b+c>0，否则c持续向左移动，这时再遍历b和c之间可能的元素，减少了一些不必要的迭代，不过也要注意c持续向左移动也不能小于b，但是c是可以退到b的，此时说明不会再有合适的c，就没必要再继续，因为当前的b不成立，下一次b只会更大，但c又是b后面的位置，所以c更大，那么永远不可能遇见合适的c，故2重循环使用的是break而不是continue。

C++实现88 ms，Python为768ms。

## 最接近的三数之和

给一个长度为n的数组nums和 目标值target，从nums中选出三个整数，使它们的和与target最接近并返回这三个数的和。

假设条件：输入数组只存在恰好一个解，不能重复使用1个元素作为答案。

### iteration解法

也是暴力匹配法，三重循环跳过重复值后，剩下的三元组求和并与target做差得到差值，如果等于0直接返回target，如果不等于0，这个差值再与ans与target的绝对值差进行比较，如果前者的差值更小也就是更接近target，就更新ans为当前三元组的元素和，ans一开始是一个较大的值。

### doublePointers解法

第1重循环跳过重复的值后，设定两个指针分别指向i+1和n-1，这是因为数组已经有序，固定a的情况下，根据b和c的动态变化可以跳过一部分循环。现在b=nums[i+1]，c=nums[n-1]，如果运气不错，a+b+c=target，就直接返回了；如果运气不好，就要比较abs(a+b+c-target)和abs(ans-target)，如果前者小说明更接近就更新target为a+b+c；更新完后，考虑b、c如何移动的问题，取决于a+b+c-target是>0还是<0；如果是>0，说明b已经有点大了，只能向左移动c，才会让c变小，从而减小差值接近0；如果是<0，说明b有点不够大，向右移动b增大差值就可以更接近0；这个过程发安抚更新ans的值，直到j>=k意味着结束，因为j=k是取了相同的元素，与假设条件不符。

## 删除有序数组的重复项

原地删除重复出现的元素，并返回删除后数组的新长度，不能使用额外的数组空间，不需要考虑数组中超出新长度后面的元素，给定的数组是有序的。

### doublePointers解法

如果数组元素个数为0，就返回0；不为0，至少有1个元素，定义2个指针都指向数组的位置1。因为数组是有序的，重复的元素必定是连续的，那么判断当前元素和前一个元素是否相等即可。如果不相等说明不是重复的，那么就把快指针的值给慢指针，慢指针向前移动，然后再移动快指针；如果相等就不必移动慢指针，只需要移动快指针，直到快指针超过数组尾元素的位置即可结束循环，此时返回slow的位置就是新数组的长度。

## 移除指定元素

移除所有数值等于val的元素，并返回移除后数组的新长度。要求不使用额外的数组空间，元素的顺序可以改变，也不需要考虑数组中超出新长度后面的元素。

### doublePointers解法

类似于删除有序数组的重复项，区别在于双指针从0开始，当快指针没到数组尾部元素之外时，如果发现快指针指向的元素等于了指定值，就跳过，让快指针继续增加；如果不相等，说明不是指定值，就让慢指针等于快指针指向对的值，然后移动慢指针，快指针也移动。



























