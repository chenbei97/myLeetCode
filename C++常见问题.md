## 什么是命名空间

命名空间是一种将库名称封装起来的办法，通过这种方法可以避免和应用程序发生命名冲突的问题。例如想使用cin和cout对象需要包含头文件< string >和< iostream>的同时，必须使用标准命名空间std。

## ++i和i++的区别

如果是单独的语句，并没有区别。得到的结果是一样的。在for循环中i++和--i作为expression也是没有区别的，因为expression是循环结束后计算出来，最后结果不会改变。

不过i++语句是需要一个临时变量取存储返回自增前的值，而++i不需要。这样就导致使用i++时系统需要先申请一段内存空间，然后将值塞进去，最后不用了才去释放。

```c++
i++;
--j;
```

如果是表达式，就会有所区别。i++是表达式先用i的值，再让i自增，所以n的值为1；++j是先把j增加1，所以表达式的值变为2，故m=2。

```c++
int i,j = 1;
int n = i++;
int m = ++j;
```

## static的修饰作用

①修饰局部变量：该变量在**静态存储区**分配内存，只能在首次函数调用中进行首次初始化，之后的函数调用不再进行初始化；其生命周期与程序相同，**但其作用域为局部作用域**，并不能一直被访问；
②修饰全局变量：该变量在**静态存储区**分配内存；在声明该变量的整个文件中都可见，文件外不可见；
③修饰普通函数：在声明该函数的整个文件中可见，文件外不可见，可在多人协作时避免同名函数冲突；
④修饰成员变量：所有类对象都只维持一份拷贝，可以实现不同对象间数据共享，无需实例化对象即可访问；不能在类内部初始化，一般在类外部初始化，并且初始化时不加static；
⑤修饰成员函数：该函数不接受this指针，只能访问类的静态成员，无需实例化对象即可访问。

## extern变量的使用

分3个情况来说明：

① 外部变量在本文件定义：该全局变量的作用域从变量的定义开始到文件末尾，如果在定义之前有函数引用了这个全局变量，就会报未定义标识符的错误，所以可在调用之前先声明这个变量为外部的，那么编译器就会优先从本文件去寻找，如果没找到，会在同一目录下的文件寻找。全局函数和全局变量的含义类似，如果在调用前没有声明过也会报错，同样可以使用extern+函数原型的办法去声明，本文件找不到就去其他文件寻找。

② 外部变量在其他文件定义：假如A文件定义了全局变量a=10，在B文件声明a为外部变量后，打印a的值就是10，优先从B文件寻找没找到就会从其它文件寻找，在A文件可以找到。但是B文件不能再次定义a=5，无论在B文件的哪个位置定义，记住定义只能有一次。

③ 外部变量在头文件定义：唯一的区别是，因为头文件可以被多次包含，这个外部变量可以在任何文件中被首次定义，但是一经定义，其他文件不能够再定义，只能够使用。所以如果非必要，不是常量表达式/数组的话不要在头文件中定义全局变量/外部变量。

## 宏定义的作用

① 宏定义可用宏代替一个在程序中经常使用的常量，常量需要修改时可以只修改宏，方便修改；

② 使用带参数的宏定义可完成函数调用的功能，减少系统开销，提高运行效率；

③ 宏定义在预处理阶段即进行了宏展开，在执行时不需要转换，可以当地执行。函数的话在调用时需要先保留现场，执行完毕后再回到现场，如果函数的功能比较简单，则离开-回到现场的花费时间可能大于函数本身执行花费的时间，宏定义不会，直接执行；

④ 宏定义相对于const常量来说，在编译阶段无法执行变量类型检查，在编译时就将定义的变量全部替换，可能会有安全问题；

⑤ 宏定义没有内存开销，仅仅是编译时期替换，不能取地址；const常量则是运行时期的变量，类型不匹配会检查出来，需要分配内存，可以取地址；

⑥ 宏定义有括号边界效应，因为宏定义的时候，各个分量未加括号，传递的参数是变量表达式，系统展开后可能由于括号优先级的问题结果不一定是正确的。

例如，在头文件定义了宏函数。

```c++
#define MUL(A,B) A*B
```

使用宏时，代码文件传入了这样的参数。

```c++
int a=1,b=2,c=3,d=0;
d=MUL(a+b,c)
```

实际上编译过程展开为

```c++
d=a+b*c
```

这时传入的是表达式，并没有把括号一起传进去

解决方法是给每个分量都加上括号，就可以避免此类问题

```c++
#define MUL(A,B) ((A)*(B))
```

再如，宏定义一个结构体指针类型，结尾没有分号。

```c++
#define dps struct s *
```

使用的时候，如下

```c++
dps p1,p2;
```

编译阶段实际展开为

```c++
struct s * p1,p2;
```

因为宏定义只是单纯的替换dps，这样p2就是普通的结构体类型，而不是指针类型了。

这种解决方法是不使用宏定义，而是使用别名typedef，注意是有分号的。

```c++
typedef  struct * dps ;
```

⑦ 宏定义加了括号也不一定保证结果正确；

例如，宏定义比较函数。

```c++
#define MIN(A,B) ((A)<(B)?(A):(B))
```

调用宏。

```c++
int a=1,b=3,min=0;
min=MIN(a++,b);
```

经过编译替换展开后，就成了

```c++
min=((a++)< (b)?(a++):(b));
```

先计算a++的表达式为1，计算逻辑表达式1<3是成立的，此时a已经为2，然后返回的是a++，等号右侧结束运算，a变成了3，并不是想要的结果1。

解决方案是使用template inline函数替代宏函数。因为这里的MAX是真正的函数，它遵守作用域和访问规则，还可以进行类型检查，还可以写出限制在class内的私有inline函数，而宏定义是无法做到的。

```c++
template<typename T>
inline T MAX(const T&x, const T&y){
    return x+y;
}
```

## inline的作用

inline函数是指，函数体可以在调用点直接展开，而无需调用，省去调用的开销。如果函数体比较小，这种声明为inline是值得的，但是如果函数体很长，例如存在循环或者递归等，就不要使用inline，这会带来代码的膨胀和较高的空间开销。

因为inline函数必须再调用点处执行，所以与普通函数不同，在每个调用点处都需要定义，也就是a.cpp和b.cpp使用inline函数时，都要定义，如果2个定义不同程序就会出现未定义的行为。所以为了避免这种事，常常把inline函数声明在头文件中，这样它对每个调用都是相同的定义。

另外inline是用于实现的关键字而非声明的关键字，所以inline要与函数定义体连在一起才起作用。声明不加inline这样做的原因是，用户无需通过阅读声明了解到这个函数是否需要内联。

```C++
inline void swap(int &x, int &y);// 与函数声明连接不起作用
void swap(int &x, int &y){ // 函数体
    int t = x;
    x = y;
    y = t;
}

void swap(int &x, int &y); // 函数声明
inline void swap(int &x, int &y){ // 与函数体在一起才起作用
    int t = x;
    x = y;
    y = t;
}
```

对于成员函数，一般是类的声明和实现放在2个文件中，这样做的原因是因为如果函数实现放在类的声明中，就会自动成为inline函数。这样类的每个实例生成都会复制一份代码，而默认构造、复制构造和析构函数等常常有较大的函数体，这样的空间开销是不必要的，调用的开销远远小于inline。

```c++
class A{
	public:
		void swap(int &x, int &y){ // 函数体在声明中实现会自动成为inline函数
            int t = x;
            x = y;
            y = t;
        }
}
```

如果swap不想作为inline函数，应该类外声明或者包含类A头文件的cpp文件定义。

```c++
// 写在包含类A头文件的cpp文件或者写在类A的头文件外部
void A::swap(int &x, int &y){ // 每个A的实例去调用这个函数,定义只有1分避免复制代码造成空间开销
    int t = x;
    x = y;
    y = t;
}
```

如果swap一定要声明为inline，为了良好的编程风格，也应当在类外声明为inline。

```c++
class A{
	public:
		void swap(int &x, int &y);
}
inline void A::swap(int &x, int &y){ //类外声明为inline函数
    int t = x;
    x = y;
    y = t;
}
```

inline函数常常用于替代宏函数，是真正的函数，有私有化的定义，可以限制作用域。

## 基类与子类指针销毁、纯虚函数的问题

### 基类与子类的互调问题

① 父类的实例可以被子类实例复制，但是反过来不成立。

说明：子类可以退化为父类，子类对象尝试赋值给父类对象时，会有一个隐式转换，将子类中父类有的成员进行复制。但是父类的实例不能赋值给子类对象，因为子类对象的某些成员在父类中没有定义。

② 父类的引用可以指向子类，但是反过来不成立。

说明：还是相同的原因，子类可以退化为父类的引用，父类不能进化为子类的引用，子类的某些成员引用不到。

③ 父类的指针可以指向子类，但是反过来不成立。

说明：同理，父类的指针可以指向子类中父类的成分，存在一个隐式转换，但是反过来子类指针是无法指向父类中不存在的子类成员。如果一定要子类指针指向父类，只能通过强转类型，但是这样不符合习惯也比较危险。

以上三种同样的结论是：

子类只能调用子类的方法，基类只能调用基类的方法。

如果子类和基类具有同名函数，根据指针的原型来确定，而不是根据指针实际指向的对象类型确定调用哪个函数，也就是应调用父类的同名函数。如果希望调用子类的同名函数，就要引入虚函数virtual，在下文会提到。

### 基类指针销毁问题

 如果基类不存在虚函数，也没有虚析构函数，基类的指针指向new出来的子类对象后，再去删除基类指针，会出现未有定义和资源泄露的情况。

```c++
class base{
    public:
    	base(){cout<<"base created\n";}
    	~base(){cout<<"base destroyed\n";}
}
class derived{
    public:
    	derived(){cout<<"derived created\n";}
    	~derived(){cout<<"derived destroyed\n";}
}
base * p = new derived();//基类指针指向子类对象
delete base;
base = nullptr;
// 终端输出结果
base created;
derived created;
base destroyed; // 基类创建->子类创建->基类销毁->??子类未被销毁(或者说子类析构函数未被调用)
```

### 虚函数virtual的引入目的

为了指向子类对象的基类指针销毁问题，引入了virtual函数，这样可以调用子类的析构函数。

关于虚函数的性质要进行几点说明：

① 纯虚拟函数不许定义其具体动作，它的存在只是为了在衍生类被重新定义，如果不需要体现多态性，不要定义虚函数；

② 拥有纯虚拟函数的类，就是抽象类，它们是不能够被实例化的，只能被继承；

③ 一个继承类没有改写父类中的纯虚函数，那么它也是抽象类，也不能被实例化；

④ 抽象类不能被实例化，但是可以定义指向抽象类的指针，以便于操纵各个衍生类；

⑤ 虚函数衍生下去仍然是虚拟函数，而且还可以省略掉关键字virtual，也就是衍生类不再特别声明为virtual也是虚函数；

⑥ 如果类有虚函数，那类就应该有一个虚析构函数。

在父类指针指向子类对象做对象销毁时，由于析构函数不是虚函数，则delete时，父类指针只能调用父类自己的析构函数，这就造成了上述对象部分销毁的错误状况，现在引入虚析构，就可以让父类指针销毁时调用子类的析构函数。

```c++
class base{
    public:
    	base(){cout<<"base created\n";}
    	virtual ~base(){cout<<"base destroyed\n";} // 现在定义为virtual函数
}
class derived{
    public:
    	derived(){cout<<"derived created\n";}
    	~derived(){cout<<"derived destroyed\n";}
}
base * p = new derived();//基类指针指向子类对象
delete base;
base = nullptr;
// 终端输出结果
base created;
derived created;
derived destroyed; // 后被创建,先被销毁
base destroyed; // 基类创建->子类创建->子类销毁->父类销毁
```

