<!--
 * @Author: chenbei
 * @Date: 2022-02-28 08:18:45
 * @LastEditTime: 2022-03-16 08:18:46
 * @Description: linkedList's leetcode analysis
 * @FilePath: \myLeetCode\linkedList\linkedList.md
 * A boy without dreams
  -->

## 奇偶链表

把奇数索引1、3、5上的元素都移到后边，偶数的移到前边。

### iteration解法



## 移除链表元素

和有序链表去重、删除重复项都不同，去重是任何元素都只保留一个，删除重复项是重复的(2个及以上)都删除不保留。本题是指定大小的元素被移除。

### iteration解法

用cur表示当前节点。如果cur的下一个节点不为空且下一个节点的节点值等于给定的val，则需要删除下一个节点。删除下一个节点可以通过cur.next = cur.next.next，就断开了被删除节点的链接。但是这个节点依然指向cur.next.next，最好将其置为空删除。下一个节点的节点值不等于给定的val，则保留下一个节点，将cur移动到下一个节点即可。下一个节点为空时，链表遍历结束，此时所有节点值等于val的节点都被删除。由于链表的头节点head 有可能需要被删除，因此创建哑节点dummy，令 dummy.next=head，初始化cur=dummy，然后遍历链表进行删除操作。最终返回dummynext 即为删除操作后的头节点。

### recursion解法

递归的终止条件是head为空，此时直接返回 head。当head不为空时，递归地进行删除操作，然后判断head 的节点值是否等于val 并决定是否要删除head。

## 反转链表

### iteration解法

从当前节点开始，用cur表示，用prev表示cur的前1个节点(初始位nullptr)，next表示cur的后1个节点，遍历链表的每个节点：第一步让cur的next指向prev，第二步让prev向前移动，也就是等于cur，第三步，让cur向前移动等于cur的next，直到cur为nullptr为止。注意第二步和第三步不能反过来，因为cur要在被cur.next覆盖之前提前交给prev。

### recursion解法

假设第nk个节点之后的节点已经被反转，但是nk-1及之前的节点没有被反转，就处于下面的状态。

n1 -> n2 -> ... -> nk-1 -> nk -> nk+1 <- nk+2 <- nk+3 <- ... <- nk+m

首先不断的递归到最深处，此时到达最后1个节点last，最后1个节点的next是nullptr或者last是nullptr时直接返回last；

然后第一轮退栈，此时当前节点是倒数第二个节点cur，让它的next的next指回自己，也就是last.next=cur，这就让最后1个节点last反转了指向。但是因为cur的next也指向了last，这形成了互指，所以让cur的next断开指向nullptr，cur的next会在下一轮递归指向cur的前一个节点prev。第一轮返回的仍然是last，因为多轮递归能满足返回条件的只有last，其它节点不是nullptr，它们的next也不是nullptr，所以不会返回任何东西；

第二轮退栈，同理cur变成了prev，此时让cur.next.next=cur，就是让prev的后1个节点的next指回prev，然后断开cur的连接避免互指，也就是prev的next=nullptr，之后同理不会返回任何东西，如此反复。

## 合并两个有序链表

### recursion解法

每次比较的共同的点是：如果第1个链表的节点是空，就返回第2个链表的节点；如果第2个链表的节点是空，就返回第1个链表的节点；如果均不为空，那么应当更新某个链表节点的next指向。如果第1个链表节点的值小于第2个链表节点的值，说明以第1个节点为基础即可，然后更新第1个节点的next，而这个next的值取决于第1个节点next的值和第2个节点的值熟大熟小。当然也可以是第2个链表节点的值比较大，那就用第2个节点的next和第1个节点去比较，来更新第2个节点的next。

这样反复递归下去，直到最后有1个链表节点是空的，就开始执行退栈过程，这个空节点作为上个节点的next，上个节点又作为上上个节点的next，一路退到最后，就是真正的list1或者list2了。

### iteration解法

我自己的解法：

首先判断均为空的情况，直接返回空指针；只要不均为空，就可以循环，所以while的条件是list1为空或者list2为空。先设定1个指针t，已经初始化过，指向某个地址，然后再用ans记录这个地址，之后更新的是t->next，ans记录的是最初的t，t更新为t->next不会影响ans。

然后先考虑均不为空的情况，那么就可以比较2个值，比较之后，让t的值等于更小的那个值，然后更新t为t->next，同时也更新那个更小的list1或list2为其next。这个操作的前提是，t在更新为t->next之前，要先给t->next新建new1个节点，否则t更新完是空指针，下次再比较就会出问题。如果2个值相等，只需要让t和t->next的值都等于这个值，然后同理t更新到t->next->next之前都要事先new出个节点，再去更新list1和list2指向自己的下一个节点。但是这样可能会导致，list1和list2更新完后while直接退出。t多new了个节点，默认的值为0，所以还要加个判断条件，如果更新完后list1和list2都为空，先把new出来的t->next->next置为nullptr，再退出while，再返回ans；

如果2个节点有1个为空，直接让t的值等于非空节点的值，让t->next和非空节点的next相等接上即可，因为链表已经有序，直接退出循环。

官方解法：

前边是比较类似的程序，先设定t=new的节点，再让ans等于这个节点记录最初的t地址，但是这个节点当作是第1个节点的前1个节点。然后思路是，两个节点均不为空作为while条件，然后去比较2个节点的值，然后更新t的next为list1或list2的next；while结束以后至多有1个节点不为空，因为已经有序，让t直接接上非空节点即可。

## 找出链表相交节点

### doublePointers解法

两个链表均不为空时才可能相交，如果有一个为空直接返回nullptr。

均不为空时，定义指向两个链表头节点的指针pa和pb，如果pa不为空就移动pa到下一个节点，pb也是如此；直到某个指针遇到了空节点，例如pa遇见空节点，则让它重新指向b链表的头节点，然后一样pa不为空就更新，pb也是如此遇到空节点会指向a链表的头节点；直到pa和pb都指向同1个节点或者都指向空节点，就返回同一节点的地址或者mullptr。

找出相交节点的问题，大类上考虑2种情况，即测试案例是相交的和不相交的。

首先考虑2个链表确实有相交节点，如果2个链表的非相交节点个数是相同的，因为相交节点也是相同的，那么相交节点之间的那些非相交节点个数必定是相同的，那么一开始两个指针会同时到达相交节点，直接返回了；

如果2个链表非相交节点个数不同，也就是相交节点之前的那些节点个数不同，那么就不会同时到达相交节点，两个指针各自到达空节点后就会移动到对方的头节点身上。那么一开始指向较短链表头节点的指针，先到达空节点，然后移动到较长链表的头节点，再到相交节点，走过的路径为短链表的长度+长链表相交节点之前的节点；一开始指向较长链表头节点的指针，后到达空节点，再跳到较短链表的头节点，走过的路径为长链表的长度+短链表相交节点之前的节点；其实这两个路径是相同的，即两个指针会在第一次错过同时到达相交节点后，再次会同时到达相交节点。

如果2个链表每月相交节点，也就会同时到达空节点，返回nullptr。

### hashSet/hashTable解法

把链表A的所有节点地址用一个哈希集合或哈希表存起来，因为每个节点的地址是唯一的，所以哈希表或集合中所有地址是唯一的，链表B和链表A相同的那个地址存在说明相交，返回即可。

注：用哈希表其实也是可以的，因为存储的是节点地址，唯一就正确，只是时间变慢需要156ms，而哈希集合只需要80ms，双指针法更快，40ms。

set和map是不同的，<unordered_set> 和 <unordered_map>也是不同的。

① map和unordered_map的区别

 unordered_map存储机制是哈希表，不会根据key的大小进行排序，存储时根据key的hash值判断元素是否相同，内部元素是无序的。调用count函数返回被查找的元素个数只能是0或者1，unordered_map可类比于Python中的字典dict。

map中的元素是按照二叉搜索树(红黑树)存储，是有序的，在红黑树上查找的时间复杂度是O(logN)，相对于unordered_map的查询速度有所下降，但额外空间开销减小，map进行中序遍历会得到有序遍历。

如果需要内部元素自动排序，使用map，不需要排序使用unordered_map。

②set和unordered_set的区别

unordered_set基于哈希表，是无序的，unordered_set可类比于Python中的集合set。

set实现了红黑树的平衡二叉检索树的数据结构，插入元素时，它会自动调整二叉树的排列，把元素放到适当的位置，以保证每个子树根节点键值大于左子树所有节点的键值，小于右子树所有节点的键值；另外，还得保证根节点左子树的高度与右子树高度相等。平衡二叉检索树使用中序遍历算法，检索效率高于vector、deque和list等容器，另外使用中序遍历可将键值按照从小到大遍历出来。

③unordered_map和unordered_set的区别

set没有键值，本身就是键值。

## 对有序链表去重

### doublePointers解法

先判断root是否为空，是返回None；不是继续判断root的next是否为空，是直接返回root；不是说明至少有2个元素，使用双指针，一个fast指向root的next，另一个slow以root构建1个节点，定义ans指向初始的slow。

当fast和fast->next有一个为真时，while循环就继续。

否则判断fast和slow的值是否相等，不等则slow->next以fast的值去构建新节点，移动slow和fast到next节点。然后检测fast是否为空，为空直接退出while，这是防止fast更新为null节点后会因为比较2个值是否相等而导致错误，空指针没有val属性。

如果相等，就定义小while循环，当fast始终和slow值相等时，就会让fast更新到next，因为链表事先是有序的，也要检测fast是否为空，是退出小循环。退出小循环后，fast因为可能是空节点，所以也要继续检测fast，退出大循环。如果不是，就可以让slow->next以fast的值去构建新节点，更新slow到next。

### iteration解法

这个方法其实和双指针解法类似，但是区别在于无需使用new，空间复杂度变小，直接利用原有的root即可。

## 删除有序链表重复项

和上一道题的区别是，如果有重复的节点都不保留，而上边的重复项会保留1个。

### iteration解法

定义一个节点p，让它的下一个节点是root。然后p的next的next不为空时，就比较p的next和p的next.next，就更新p为p.next。这个意思是，一个节点后面的2个节点不相等，才能保证第1个节点确实不是重复的，才会更新当前节点为这后面的节点。要注意，p.next更新完后可能为空节点，加个判断提前退出，否则空节点是没有next属性的，大while会出错。

否则的话从这个节点后面的第1个节点开始，记录这个节点的值x，只要p.next的值没变，就更新p.next，注意：是更新p.next为p.next.next，直到不等于这个值为止，说明p.next确实不是重复项了再更新p为p.next。还要注意p.next可能更新为None的情况，要判断提前退出，否则空节点是没有val的，无法与x比较。

双指针其实也可以，但是写出来基本上和迭代法没有太多差异，不在给出。

## 删除链表倒数第n个节点

### iteration解法

先计算链表的长度，根据长度确定要移除节点的前一个节点，让这个节点的next直接指向节点的next.next即可，但是要注意移除的这个节点是否是第1个节点，如果是，直接让next为空即可。

### doublePointers解法

依据数学计算公式，假设有m个节点，要移除的是倒数第n个节点，以编号1开始的话，移除的节点位置是n-m+1，所以需要到达第n-m个节点，让它的next执行next.next即可。有个特殊情况时，n=m的时候，其实移除的就是第1个节点，因为没有第0个节点，所以这个情况要特殊处理。

定义2个指针fast和slow，一开始都指向root。现在只有一个数n，利用n可以先让fast指针到达第n+1个节点的位置。因为n可以为m，所以fast指针移动后可以是空指针，即移动m次，此时作为特殊情况，直接返回slow的next即可，因为删除的是第1个节点；如果n不为m，因为fast已经在n+1的位置，凑出n-m，自然是先让m减去n+1，也就是让fast移动到最后1个节点，位置为m，所以这样while执行了n-m-1次，判断条件是fast->next不为空，同时slow也更新。因为slow本来是在1的位置，所以移动n-m-1次就到达了位置n-m，此时让slow->next=slow->next->next即可。

### stack解法

用栈把链表的每个节点都入栈，由于栈先入后出，所以可以把栈的前n个top删掉，再次获取top就是要删除的节点的前驱节点，让它的next指向next.nex即可。

## 判断是否为环形链表

### hashTable解法

遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。那么遍历的时候用map来存储，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。

### doublePointers解法

快指针初始指向root.next，慢指针指向root，快指针每次移动2步，慢指针1步，如果2个有1个到达了nullptr就说明不是环链表，否则一定某时刻追上，两个指针指向同一个节点，所以相等时就返回true。不过因为一开始fast指向root.next，所以要事先判断一下root.next，如果为nullptr就不是环，否则，第2个节点可以接回第1个节点或者下一个节点，那就比较2个指针的信息即可。

## 对链表进行插入排序

### iteration解法

插入排序：初始有1个元素，之后每次总是插入合适的位置使之有效，如果是数组的插入排序，插入排序位置后面的元素都要向后移动一位，而且数组事先得多申请内存。如果是链表，只需要插入位置前的节点的next和插入的节点连接上即可，然后让插入的节点连上前一个节点原本的next。不过由于找到插入位置需要从头遍历，所以时间复杂度实际上还是O(n^2)。

首先判断给定的链表是否为空，若为空，则不需要进行排序，直接返回。

引入哑节点，便于在head节点之前插入节点，可以让dummy.next=root。

设定1个指针lastSorted指向链表的已排序部分的最后1个节点，因为插入排序初始有1个元素，从第2个元素开始，已排序的就是第1个，所以初始指向root。设定待插入的元素为cur，从第2个元素开始，初始为root.next，这里可以知道cur总是lastSorted的后1个节点。比较lastSorted和cur的值，决定插入位置，如果cur大就直接插在后边，更新lastSorted为cur；cur小就与lastSorted的前一个继续去比较，这个节点用prev来维护，不过由于链表的单向性，只能让prev指向dummy节点，当它的下一个还小于cur的时候，就移动prev，否则说明prev到达了比cur小的最大节点。这个时候lastSorted不用动，但是它的下一个不再是cur，因为cur跑到前边了，那么cur的next接在lastSorted的next即可。然后cur的next接上原本prev的next，prev的next更新为新节点cur。

以上操作是在cur不为空节点时就执行，运行结束后，dummy节点后边就排好了，返回dummy->next即可。
