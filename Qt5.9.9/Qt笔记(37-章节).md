## QML交互

### 向QML公开C++类型的属性

QML可以很容易地用C++代码中定义的功能进行扩展。由于QML引擎与Qt元对象系统的紧密集成，**任何由QObject派生类适当公开的功能都可以从QML代码中访问**。这使得C++数据和函数可以直接从QML访问，通常只需很少或根本不需要修改。
QML引擎具有通过元对象系统内省QObject实例的能力。这意味着任何QML代码都可以访问QObject派生类实例的以下成员：Properties Methods（**前提是它们是公共槽或用Q_INVOKABLE标记**）Signals（此外，如果**枚举是用Q_enums声明的，则它们是可用的**。有关更多详细信息，请参阅《QML和C++之间的数据类型转换》。）通常，无论是否已经向QML类型系统注册了QObject派生类，这些都可以从QML访问。但是，如果要以要求引擎访问其他类型信息的方式使用类，例如，如果要将类本身用作方法参数或属性，或者如果要以这种方式使用其枚举类型之一，则可能需要注册该类。
还要注意，本文档中涵盖的许多重要概念在用《C++编写QML扩展教程》中进行了演示。

#### 数据类型处理和所有权

从C++传输到QML的任何数据，无论是**属性值、方法参数或返回值，还是信号参数值**，都必须是QML引擎支持的类型。默认情况下，该引擎支持许多Qt C++类型，并且在从QML使用时可以适当地自动转换它们。此外，在QML类型系统中注册的C++类可以用作数据类型，如果适当地注册了它们的枚举也可以。有关更多信息，请参阅《QML和C++之间的数据类型转换》。
此外，当数据从C++传输到QML时，还会考虑数据所有权规则。有关更多详细信息，请参阅数据所有权。

#### 暴露属性

可以使用Q_property()宏为任何QObject派生类指定属性。属性是一个类数据成员，具有关联的读取函数和可选的写入函数。可以从QML访问QObject派生类的所有属性。
例如，下面是一个具有author属性的Message类。正如Q_PROPERTY宏调用所指定的，此属性可通过author()方法读取，也可通过setAuthor()方法写入：

```c++
  class Message : public QObject
  {
      Q_OBJECT
      Q_PROPERTY(QString author READ author WRITE setAuthor NOTIFY authorChanged)
  public:
      void setAuthor(const QString &a) {
          if (a != m_author) {
              m_author = a;
              emit authorChanged();
          }
      }
      QString author() const {
          return m_author;
      }
  signals:
      void authorChanged();
  private:
      QString m_author;
  };
```

如果在从C++加载名为MyItem.qml的文件时将此类的实例设置为上下文属性，使用**setContextProperty**函数：

```c++
  int main(int argc, char *argv[]) {
      QGuiApplication app(argc, argv);

      QQuickView view;
      Message msg;
      view.engine()->rootContext()->setContextProperty("msg", &msg);
      view.setSource(QUrl::fromLocalFile("MyItem.qml"));
      view.show();

      return app.exec();
  }
```

然后，可以从MyItem.qml中读取author属性：

```c++
  // MyItem.qml
  import QtQuick 2.0

  Text {
      width: 100; height: 100
      text: msg.author    // invokes Message::author() to get this value

      Component.onCompleted: {
          msg.author = "Jonah"  // invokes Message::setAuthor()
      }
  }
```

为了最大限度地与QML互操作，**任何可写的属性都应该有一个相关的NOTIFY信号**，每当属性值发生变化时就会发出该信号。这允许属性与属性绑定一起使用，这是QML的一个基本功能，它通过在任何依赖项的值发生变化时自动更新属性来强制执行属性之间的关系。
在上面的例子中，author属性的相关NOTIFY信号是authorChanged，正如在Q_property()宏调用中指定的那样。这意味着，无论何时发出信号——就像作者在Message:：setAuthor()中更改时一样——这都会通知QML引擎必须更新任何涉及author属性的绑定，反过来，引擎将通过再次调用Message:：autho()来更新文本属性。
如果author属性是可写的，但没有关联的NOTIFY信号，则文本值将使用Message:：author()返回的初始值进行初始化，但不会使用以后对此属性的任何更改进行更新。此外，任何从QML绑定到属性的尝试都会从引擎中产生运行时警告。
注意：建议将NOTIFY信号命名为＜property＞Changed，其中＜property＞是属性的名称。QML引擎生成的相关属性更改信号处理程序将始终采用<property>Changed上的形式，而不管相关C++信号的名称如何，因此建议信号名称遵循此约定以避免任何混淆。

#### 通知信号使用注意事项

为了防止循环或过度求值，开发人员应确保只有在属性值实际发生更改时才会发出属性更改信号。此外，如果一个属性或一组属性很少使用，则允许对多个属性使用相同的NOTIFY信号。这样做时应该小心，以确保性能不会受到影响。
NOTIFY信号的存在确实会产生较小的开销。在某些情况下，特性的值是在对象构造时设置的，随后不会更改。最常见的情况是，一个类型使用分组属性，并且分组属性对象被分配一次，并且只有在删除对象时才释放。在这些情况下，可以将CONSTANT属性添加到属性声明中，而不是NOTIFY信号。
CONSTANT属性应仅用于其值仅在类构造函数中设置并最终确定的属性。所有其他要在绑定中使用的属性都应该具有NOTIFY信号。

#### 具有对象类型的特性

对象类型属性可从QML访问，前提是对象类型已在QML类型系统中适当注册。
例如，Message类型可能具有MessageBody*类型的body属性：

```c++
  class Message : public QObject
  {
      Q_OBJECT
      Q_PROPERTY(MessageBody* body READ body WRITE setBody NOTIFY bodyChanged)
  public:
      MessageBody* body() const;
      void setBody(MessageBody* body);
  };

  class MessageBody : public QObject
  {
      Q_OBJECT
      Q_PROPERTY(QString text READ text WRITE text NOTIFY textChanged)
  // ...
  }
```

假设Message类型已在QML类型系统中注册，允许将其用作QML代码中的对象类型：

```c++
  Message {
      // ...
  }
```

如果MessageBody类型也在类型系统中注册，则可以将MessageBody分配给Message的body属性，所有这些都来自QML代码：

```c++
  Message {
      body: MessageBody {
          text: "Hello, world!"
      }
  }
```

#### 具有对象列表类型的特性

包含QObject派生类型列表的属性也可以公开给QML。然而，出于这个目的，应该使用QQmlListProperty而不是QList<T>作为属性类型。这是**因为QList不是QObject派生的类型**，因此无法通过Qt元对象系统提供必要的QML属性特征，例如修改列表时的信号通知。
例如，下面的MessageBoard类具有类型为QQmlListProperty的消息属性，该属性存储消息实例列表：

```c++
  class MessageBoard : public QObject
  {
      Q_OBJECT
      Q_PROPERTY(QQmlListProperty<Message> messages READ messages)
  public:
      QQmlListProperty<Message> messages();

  private:
      static void append_message(QQmlListProperty<Message> *list, Message *msg);

      QList<Message *> m_messages;
  };
```

MessageBoard::messages()函数只是从其QList＜T＞m_messages成员中创建并返回一个QQmlListProperty，并根据QQmlListProperty构造函数的要求传递适当的列表修改函数：

```c++
  QQmlListProperty<Message> MessageBoard::messages()
  {
      return QQmlListProperty<Message>(this, 0, &MessageBoard::append_message);
  }

  void MessageBoard::append_message(QQmlListProperty<Message> *list, Message *msg)
  {
      MessageBoard *msgBoard = qobject_cast<MessageBoard *>(list->object);
      if (msg)
          msgBoard->m_messages.append(msg);
  }
```

请注意，QQmlListProperty的模板类类型（在本例中为Message）必须在QML类型系统中注册。

#### 分组属性

任何只读对象类型的属性都可以作为分组属性从QML代码中访问。这可以用于公开一组相关属性，这些属性描述了类型的一组属性。例如，假设Message::author属性的类型为MessageAuthor，而不是简单的字符串，其子属性为name和email:

```c++
 class MessageAuthor : public QObject
  {
      Q_PROPERTY(QString name READ name WRITE setName)
      Q_PROPERTY(QString email READ email WRITE setEmail)
  public:
      ...
  };

  class Message : public QObject
  {
      Q_OBJECT
      Q_PROPERTY(MessageAuthor* author READ author)
  public:
      Message(QObject *parent)
          : QObject(parent), m_author(new MessageAuthor(this))
      {
      }
      MessageAuthor *author() const {
          return m_author;
      }
  private:
      MessageAuthor *m_author;
  };

```

author属性可以使用QML中的分组属性语法写入，如下所示：

```c++
  Message {
      author.name: "Alexandra"
      author.email: "alexandra@mail.com"
  }
```

作为分组属性公开的类型与对象类型属性的不同之处在于，分组属性是只读的，并且在构造时由父对象初始化为有效值。分组属性的子属性可以从QML修改，但分组属性对象本身永远不会改变，而对象类型属性可以随时从QML分配新的对象值。因此，分组属性对象的生存期严格由C++父实现控制，而对象类型属性可以通过QML代码自由创建和销毁。

#### 曝光方法（包括Qt插槽）

任何QObject派生类型的方法都可以从QML代码中访问，如果它是：用Q_INVOKABLE()宏标记的公共方法是公共Qt槽的方法例如，下面的MessageBoard类有一个用Q_INVOKABLE宏标记的postMessage()方法，以及一个作为公共槽的refresh()方法：

```c++
  class MessageBoard : public QObject
  {
      Q_OBJECT
  public:
      Q_INVOKABLE bool postMessage(const QString &msg) {
          qDebug() << "Called the C++ method with" << msg;
          return true;
      }

  public slots:
      void refresh() {
          qDebug() << "Called the C++ slot";
      }
  };
```

如果MessageBoard的一个实例被设置为文件MyItem.qml的上下文数据，那么MyItem.qml可以调用下面示例中所示的两个方法：

```c++
  int main(int argc, char *argv[]) {
      QGuiApplication app(argc, argv);

      MessageBoard msgBoard; // 实例
      QQuickView view;
      view.engine()->rootContext()->setContextProperty("msgBoard", &msgBoard);
      view.setSource(QUrl::fromLocalFile("MyItem.qml"));
      view.show();

      return app.exec();
  }


  // MyItem.qml
  import QtQuick 2.0

  Item {
      width: 100; height: 100

      MouseArea {
          anchors.fill: parent
          onClicked: {
              var result = msgBoard.postMessage("Hello from QML")//可以使用实例的方法
              console.log("Result of postMessage():", result)
              msgBoard.refresh();// 和槽函数
          }
      }
  }
```

如果C++方法具有QObject*类型的参数，则可以使用引用该对象的对象id或JavaScript var值从QML传递参数值。
QML支持调用重载的C++函数。如果有多个C++函数具有相同的名称但参数不同，则会根据提供的参数的数量和类型调用正确的函数。
当从QML中的JavaScript表达式访问时，从C++方法返回的值将转换为JavaScript值。

#### 暴露信号

任何QObject派生类型的公共信号都可以从QML代码中访问。
QML引擎**自动为从QML使用的QObject派生类型的任何信号创建信号处理程序**。信号处理程序总是以<Signal>命名，其中<Signal]是信号的名称，第一个字母大写。信号传递的所有参数都可以通过参数名称在信号处理程序中使用。
例如，假设MessageBoard类有一个带有单个参数的newMessagePosted()信号，subject：

```c++
  class MessageBoard : public QObject
  {
      Q_OBJECT
  public:
     // ...
  signals:
     void newMessagePosted(const QString &subject);
  };
```

如果MessageBoard类型已在QML类型系统中注册，则QML中声明的MessageBoard对象可以使用名为onNewMessagePosted的信号处理程序接收newMessagePosted()信号，并检查主题参数值：

```c++
  MessageBoard {
      onNewMessagePosted: console.log("New message received:", subject)
  }
```

与属性值和方法参数一样，信号参数必须具有QML引擎支持的类型；请参阅《QML和C++之间的数据类型转换》。（使用未注册的类型不会产生错误，但处理程序无法访问参数值。）类可能有多个同名信号，但只有最后一个信号可以作为QML信号访问。请注意，具有相同名称但不同参数的信号不能彼此区分。

### QML和C++之间的数据类型转换

当在QML和C++之间交换数据值时，QML引擎将其转换为具有适合在QML或C++中使用的正确数据类型。这就要求交换的数据是引擎可以识别的类型。
QML引擎提供了对大量Qt C++数据类型的内置支持。此外，可以向QML类型系统注册自定义C++类型，以使它们可用于引擎。
本页讨论QML引擎支持的数据类型，以及如何在QML和C++之间进行转换。

**当数据从C++传输到QML时，数据的所有权始终由C++保留**。此规则的例外情况是从显式C++方法调用返回QObject时：在这种情况下，QML引擎承担对象的所有权，除非通过调用指定了QQmlEngine:：CppOwnership的QQmlEngine：setObjectOwnership()，明确设置了对象的所有权保留在C++中。
此外，QML引擎尊重Qt C++对象的正常QObject父所有权语义，并且永远不会删除具有父对象的QObject实例。

#### 基本类型

默认识别的基本类型如下。

|                  Qt Type                  |           QML Type           |
| :---------------------------------------: | :--------------------------: |
|                   bool                    |             bool             |
|             unsigned int,int              |             int              |
| Enums declared with Q_ENUM() or Q_ENUMS() |         enumeration          |
|               float, qreal                |            qreal             |
|                  double                   |            double            |
|                  QString                  |            string            |
|                   QUrl                    |             url              |
|                  QColor                   |            color             |
|                   QFont                   |             font             |
|                 QDateTime                 |             date             |
|              QPoint, QPointF              |            point             |
|               QSize, QSizeF               |             size             |
|               QRect, QRectF               |             rect             |
|                QMatrix4x4                 |          matrix4x4           |
|                QQuaternion                |          quaternion          |
|      QVector2D, QVector3D, QVector4D      | vector2d, vector3d, vector4d |

注：Qt GUI模块提供的类，如QColor、QFont、QQuaternion和QMatrix4x4，**仅在包含Qt Quick模块时**才可从QML获得。
为了方便起见，可以在QML中通过字符串值或通过QtQml::Qt对象提供的相关方法指定这些类型中的许多类型。例如，Image::sourceSize属性的类型为size（自动转换为QSize类型），可以由格式化为“widthxheight”的字符串值或Qt.size()函数指定：

```c++
  Item {
      Image { sourceSize: "100x200" }
      Image { sourceSize: Qt.size(100, 200) }
  }
```

#### QObject派生类类型

任何QObject派生的类都可以用作QML和C++之间数据交换的类型，前提是该类已经在QML类型系统中注册。
该引擎允许注册可实例化类型和不可实例化类型。一旦一个类被注册为QML类型，它就可以被用作在QML和C++之间交换数据的数据类型。有关类型注册的更多详细信息，请参阅使用《QML类型系统注册C++类型》。

#### Qt和JavaScript类型之间的转换

QML引擎内置支持在QML和C++之间传输数据时，将许多Qt类型转换为相关的JavaScript类型，反之亦然。这使得使用这些类型并在C++或JavaScript中接收它们成为可能，而无需实现提供对数据值及其属性的访问的自定义类型。
（请注意，QML中的JavaScript环境修改了原生JavaScript对象原型，包括String、Date和Number的原型，以提供额外的功能。有关更多详细信息，请参阅JavaScript主机环境。）

#### QVariantList和QVariantMap到JavaScript数组和对象

QML引擎提供了QVariantList和JavaScript数组之间以及QVariantMap和JavaScript对象之间的自动类型转换。
例如，下面QML中定义的函数需要两个参数，一个数组和一个对象，并使用数组和对象项访问的标准JavaScript语法打印它们的内容。下面的C++代码调用此函数，分别传递QVariantList和QVariantMap，它们将自动转换为JavaScript数组和对象值：

```c++
QML
  // MyItem.qml
  Item {
      function readValues(anArray, anObject) {
          for (var i=0; i<anArray.length; i++)
              console.log("Array item:", anArray[i])

          for (var prop in anObject) {
              console.log("Object item:", prop, "=", anObject[prop])
          }
      }
  }

C++

  // C++
  QQuickView view(QUrl::fromLocalFile("MyItem.qml"));

  QVariantList list;
  list << 10 << QColor(Qt::green) << "bottles";

  QVariantMap map;
  map.insert("language", "QML");
  map.insert("released", QDate(2010, 9, 21));

  QMetaObject::invokeMethod(view.rootObject(), "readValues",
          Q_ARG(QVariant, QVariant::fromValue(list)),
          Q_ARG(QVariant, QVariant::fromValue(map)));
// output: 
Array item: 10
  Array item: #00ff00
  Array item: bottles
  Object item: language = QML
  Object item: released = Tue Sep 21 2010 00:00:00 GMT+1000 (EST)
```

类似地，如果C++类型使用QVariantList或QVariantMap类型作为属性类型或方法参数，则该值可以在QML中创建为JavaScript数组或对象，并在传递给C++时自动转换为QVariantList或QVariant Map。
请注意，C++类型的QVariantList和QVariantMap属性存储为值，不能由QML代码就地更改。只能替换整个地图或列表，但不能操作其内容。如果属性l是QVariantList，则以下代码不起作用：

```c++
  MyListExposingItem {
     l: [1, 2, 3]
     Component.onCompleted: l[0] = 10
         
 // 改为
  MyListExposingItem {
     l: [1, 2, 3]
     Component.onCompleted: l = [10, 2, 3]
  }
```

#### QDateTime到JavaScript日期

QML引擎提供QDateTime值和JavaScriptDate对象之间的自动类型转换。
例如，下面QML中定义的函数需要一个JavaScriptDate对象，还返回一个具有当前日期和时间的新Date对象。下面的C++代码调用此函数，传递一个QDateTime值，该值在传递给readDate（）函数时由引擎自动转换为Date对象。反过来，readDate（）函数返回一个Date对象，该对象在C++中接收时会自动转换为QDateTime值：

```c++

QML

  // MyItem.qml
  Item {
      function readDate(dt) {
          console.log("The given date is:", dt.toUTCString());
          return new Date();
      }
  }

C++

  // C++
  QQuickView view(QUrl::fromLocalFile("MyItem.qml"));

  QDateTime dateTime = QDateTime::currentDateTime();
  QDateTime retValue;

  QMetaObject::invokeMethod(view.rootObject(), "readDate",
          Q_RETURN_ARG(QVariant, retValue),
          Q_ARG(QVariant, QVariant::fromValue(dateTime)));

  qDebug() << "Value returned from readDate():" << retValue;
```

类似地，如果C++类型使用QDateTime作为属性类型或方法参数，则该值可以在QML中创建为JavaScriptDate对象，并在传递给C++时自动转换为QDateTime值。

#### Enumeration Types

要将自定义枚举用作数据类型，必须注册其类，并且还必须使用Q_ENUM()声明枚举，以便将其注册到Qt的元对象系统中。例如，下面的Message类有一个Status枚举：

```c++
  class Message : public QObject
  {
      Q_OBJECT
      Q_PROPERTY(Status status READ status NOTIFY statusChanged)
  public:
      enum Status {
          Ready,
          Loading,
          Error
      };
      Q_ENUM(Status)
      Status status() const;
  signals:
      void statusChanged();
  };
```

如果Message类已在QML类型系统中注册，则可以从QML中使用其Status枚举：

```c++
  Message {
       onStatusChanged: {
           if (status == Message.Ready)
               console.log("Message is loaded!")
       }
   }
```

注意：枚举值的名称必须以大写字母开头，才能从QML访问。

```c++
  enum class Status {
            Ready,
            Loading,
            Error
  }
  Q_ENUM(Status)
```

枚举类在QML中注册为作用域和非作用域属性。Ready值将在Message.Status.Ready和Message.Ready中注册。
使用枚举类时，可以有多个枚举使用相同的标识符。未受范围限制的注册将被上次注册的枚举覆盖。对于包含此类名称冲突的类，可以通过使用特殊的**Q_CLASSINFO宏注释类来禁用无范围注册。使用带有值false的RegisterEnumClassesUnscoped名称可以防止作用域枚举合并到同一名称空间中**。

```c++
  class Message : public QObject
      {
          Q_OBJECT
          Q_CLASSINFO("RegisterEnumClassesUnscoped", "false")
          Q_ENUM(ScopedEnum)
          Q_ENUM(OtherValue)

      public:
          enum class ScopedEnum {
                Value1,
                Value2,
                OtherValue
          };
          enum class OtherValue {
                Value1,
                Value2
          };
      };
```

#### 作为信号和方法参数的枚举类型

**具有枚举类型参数的C++信号和方法可以从QML中使用**，前提是**枚举和信号或方法都在同一类中声明**，或者枚举值是Qt命名空间中声明的值之一。
此外，如果带有枚举参数的C++信号应该可以使用connect()函数连接到QML函数，则必须使用qRegisterMetaType()注册枚举类型。
对于QML信号，可以使用int类型将枚举值作为信号参数传递：

```c++
  Message {
      signal someOtherSignal(int statusValue)

      Component.onCompleted: {
          someOtherSignal(Message.Loading)
      }
  }
```



### QML类型系统注册C++类型

可以向QML类型系统注册QObject派生类，以使该类型能够用作QML代码中的数据类型。
该引擎允许注册可实例化类型和不可实例化类型。注册可实例化类型使C++类能够用作QML对象类型的定义，从而允许在QML代码的对象声明中使用它来创建此类型的对象。注册还为引擎提供了额外的类型元数据，使类型（以及类声明的任何枚举）能够用作QML和C++之间交换的属性值、方法参数和返回值以及信号参数的数据类型。
注册不可实例化的类型也以这种方式将类注册为数据类型，但该类型不能用作QML中的QML对象类型。例如，如果一个类型具有应该向QML公开的枚举，但该类型本身不应该是可实例化的，那么这是有用的。

有关选择向QML公开C++类型的正确方法的快速指南，请参阅在《C++和QML之间选择正确的集成方法》。

#### 注册可实例化对象类型

任何QObject派生的C++类都可以注册为QML对象类型的定义。一旦类在QML类型系统中注册，就可以像QML代码中的任何其他对象类型一样声明和实例化该类。一旦创建，就可以从QML操作类实例；正如向QML公开C++类型的属性所解释的那样，**任何QObject派生类的属性、方法和信号都可以从QML代码中访问**。
要将QObject派生类注册为可实例化的QML对象类型，请调用qmlRegisterType()将该类注册为特定类型命名空间中的QML类型。然后，客户端可以导入该命名空间以便使用该类型。
例如，假设有一个Message类具有author和creationDate属性：

```c++
  class Message : public QObject
  {
      Q_OBJECT
      Q_PROPERTY(QString author READ author WRITE setAuthor NOTIFY authorChanged)
      Q_PROPERTY(QDateTime creationDate READ creationDate WRITE setCreationDate NOTIFY creationDateChanged)
  public:
      // ...
  };
```

可以通过调用具有适当类型命名空间和版本号的qmlRegisterType()来注册此类型。例如，要使该类型在com.mycompany.messaging命名空间中的版本为1.0，请执行以下操作：

```c++
qmlRegisterType<Message>("com.mycompany.messaging", 1, 0, "Message");
```

该类型可以在QML的对象声明中使用，并且可以读取和写入其属性，如下例所示：

```c++
  import com.mycompany.messaging 1.0

  Message {
      author: "Amelie"
      creationDate: new Date()
  }
```

#### 注册不可实例化的类型

有时，QObject派生类可能需要向QML类型系统注册，但不能作为可实例化类型注册。例如，如果一个C++类：是一个不应实例化的接口类型，是一个无需向QML公开的基类类型，则会出现这种情况。它声明了一些应从QML访问的枚举，但否则不应实例化。是一个应通过单例实例提供给QML的类型，并且不应该从QML实例化Qt QML模块提供了几种注册不可实例化类型的方法：qmlRegisterType（）（不带参数）注册一个不可实例化且不能从QML引用的C++类型。这使引擎能够强制从QML实例化的任何继承类型。
qmlRegisterInterface（）注册一个现有的Qt接口类型。该类型不能从QML实例化，并且不能用它声明QML属性。不过，从QML使用此类型的C++属性将执行预期的接口强制转换。
qmlRegisterUnreatableType（）注册一个命名的C++类型，该类型不可实例化，但应可识别为QML类型系统的类型。如果类型的枚举或附加属性应该可以从QML访问，但类型本身不应该是可实例化的，那么这一点非常有用。
qmlRegisterSingletonType（）注册一个可以从QML导入的单例类型，如下所述。
请注意，在QML类型系统中注册的所有C++类型都必须是QObject派生的，即使它们是不可实例化的。

##### 使用Singleton类型注册Singleton对象

单例类型使属性、信号和方法能够在命名空间中公开，而不需要客户端手动实例化对象实例。QObject单例类型尤其是提供功能或全局属性值的一种高效而方便的方式。
请注意，单例类型没有关联的QQmlContext，因为它们在引擎中的所有上下文中共享。QObject单例类型实例由QQmlEngine构建和拥有，并且在引擎被销毁时将被销毁。
QObject单例类型可以以类似于任何其他QObject或实例化类型的方式进行交互，只是只存在一个（引擎构建和拥有的）实例，并且它必须由类型名称而不是id引用。QObject单个类型的Q_PROPERTY可以绑定到，QObject模块API的Q_INVOKABLE函数可以在信号处理程序表达式中使用。这使得singleton类型成为实现样式化或主题化的理想方式，而且它们也可以代替“.ppragma库”脚本导入来存储全局状态或提供全局功能。
一旦注册，就可以像向QML公开的任何其他QObject实例一样导入和使用QObject单例类型。以下示例假设一个QObject单例类型已注册到版本为1.0的“MyThemeModule”命名空间中，其中该QObject具有QColor“color”Q_PROPERTY：

```c++
  import MyThemeModule 1.0 as Theme

  Rectangle {
      color: Theme.color // binding.
  }
```

QJSValue也可以作为单例类型公开，但是客户端应该知道，这种单例类型的属性不能绑定到。
有关如何实现和注册新的单例类型以及如何使用现有单例类型的更多信息，请参阅qmlRegisterSingletonType（）。
注意：QML中已注册类型的枚举值应以大写字母开头。

### C++编写QML扩展教程



### QQuickWindow

QQuickWindow提供了与QQuickItems的场景交互和显示所需的图形场景管理。
QQuickWindow总是有一个不可见的根项目。若要将项目添加到此窗口，请将这些项目重设为根项目或场景中的现有项目。
要轻松显示QML文件中的场景，请参阅QQuickView

### QQuickView

这是QQuickWindow的一个子类，当给出主源文件的URL时，它将自动加载并显示QML场景。或者，您可以使用QQmlComponent实例化自己的对象，并将它们放置在手动设置的QQuickWindow中。

要接收与使用QQuickView加载和执行QML相关的错误，您可以连接到statusChanged()信号并监视QQuickView:：Error。这些错误可通过QQuickView:：error()获得。
QQuickView还管理视图和根对象的大小。默认情况下，resizeMode为SizeViewToRootObject，它将加载组件并将其调整为视图的大小。或者，resizeMode可以设置为SizeRootObjectToView，这将使视图的大小调整为根对象的大小。典型代码使用方式。

```c++
  int main(int argc, char *argv[])
  {
      QGuiApplication app(argc, argv);

      QQuickView *view = new QQuickView;
      view->setSource(QUrl::fromLocalFile("myqmlfile.qml"));
      view->show();
      return app.exec();
  }
```

### QQuickWidget

这是QQuickWindow的一个方便包装器，当给出主源文件的URL时，它将自动加载并显示QML场景。或者，您可以使用QQmlComponent实例化自己的对象，并将它们放置在手动设置的QQuickWidget中。

```c++
  QQuickWidget *view = new QQuickWidget;
  view->setSource(QUrl::fromLocalFile("myqmlfile.qml"));
  view->show();
```

要接收与使用QQuickWidget加载和执行QML相关的错误，您可以连接到statusChanged()信号并监视QQuickWidget:：Error。这些错误可通过QQuickWidget:：errors()获得。
QQuickWidget还管理视图和根对象的大小。默认情况下，resizeMode为SizeViewToRootObject，它将加载组件并将其调整为视图的大小。或者，resizeMode可以设置为SizeRootObjectToView，这将使视图的大小调整为根对象的大小。
注意：QQuickWidget是使用QQuickView和QWidget:：createWindowContainer()的替代方案。堆叠顺序的限制不适用，使QQuickWidget成为更灵活的替代品，表现得更像一个普通的小部件。这是以牺牲性能为代价的。与QQuickWindow和QQuickView不同，QQuickWidget涉及渲染到OpenGL帧缓冲区对象中。这自然会带来轻微的性能打击。
注意：使用QQuickWidget将禁用所有平台上的线程渲染循环。这意味着线程渲染的一些好处，例如Animator类和vsync驱动的动画，将不可用。
注意：避免在QQuickWidget上调用winId()。此函数会触发创建本机窗口，从而导致性能降低，并可能出现渲染故障。QQuickWidget的全部目的是在没有单独的本地窗口的情况下渲染Quick场景，因此应始终避免将其作为本地小部件。

### QQmlComponent



### QQmlListProperty