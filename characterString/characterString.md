<!--
 * @Author: chenbei
 * @Date: 2022-03-03 08:06:47
 * @LastEditTime: 2022-03-16 08:02:19
 * @Description: charaterString's leetcode analysis
 * @FilePath: \myLeetCode\characterString\characterString.md
 * A boy without dreams
-->
## 字符串退格问题

### stack解法

用2个栈去接收新构建的字符串，遍历每个字符串的字符，如果字符是'#'且栈空时跳过，否则的话如果字符是'#'但是不栈空就可以退栈1个元素，字符不是'#'就可以入栈。

最后比较2个栈的size，不相等一定不相等，相等时再依次比较每个元素。

### string解法

利用string本身也是容器，使用push_back和pop_back有同样的效果，判别重构后的字符串只需要使用"=="，不必再遍历。

### doublePointers解法

逆序遍历第1个字符串，遇见'#'时就知道有1个字符要被删除，定义要被删除字符数量的变量skip，让它增1，这个含义并不是真的删除原来字符串这个字符，而是跳过它，即逆序遍历的时候，让控制变量多减一次。如果是普通字符，它是否删除取决于skip是否为0，如果需要删除，skip在这之前已经+1，所以skip不会为0，就让它-1。如果skip已经为0，就先退出等待。

同样方法处理第2个字符串，如果有'#'也会跳过，控制变量多减一次，最后也会退出等待。

此时2个while循环都退出，分别停留的2个字符进行比较，不过比较的前提是，控制变量都大于等于0，否则会越界，如果不满足都大于等于0，但是至少有1个不为0，说明退格后2个字符串长度不一样，也可以直接返回false。在都大于等于0的条件下，去比较2个字符，此时退格的字符都已经删除，如果不相等，直接返回false即可。如果相等，应当进入下一次循环，控制变量正常的减1即可。

## 字符串括号匹配问题

### stack解法

此题的前提是字符串只由括号类型字符组成，字符串长度为奇数的话一定不匹配。

遍历字符串的每个字符，如果是左括号，入栈；如果是右括号，如果栈空或者栈顶元素不和右括号匹配，直接返回false，因为匹配的括号总是最近的那个括号，也就是栈顶。如果匹配了，就删除栈中匹配过的左括号，继续下一个字符的判断。

## 字符串计算表达式

字符串只有加减乘除运算符，没有括号，除法要求是整除。

### stack解法

乘除优先于加减计算，考虑先进行所有乘除运算。定义一个栈，然后遍历每个字符，是数字的话，先计算它的大小，由于数字可能是连续的，所以应当用 num=num * 10 + int(s[i] - '0')计算，直到字符不是数字。此时字符不是数字，且它不是空格符，就说明是运算符，可以根据上一次运算符的状态(初始第1个数字之前认为是'+')，如果是'+'直接入栈，'-'就入栈相反数，'*'就计算栈顶元素和当前num的乘积，并更新到栈顶元素，栈顶元素在有效表达式的情况下，乘除之前必定会有元素压栈，不必担心栈顶元素为空的情况，除法同理。还要考虑一个情况，最后1个字符的情况，假如是A * B，A是数字，计算num，跳过，然后遇见 ' * '，它不是数字和空格符就会执行上一次sign='+'的选项，把A入栈，然后更新sign=' * '，num=0；然后下一个字符B，也就是最后1个字符，它是数字，计算num=B，然后就跳过了，因为B不满足非数字的条件，那么运算就丢失，所以还需要加个条件。、

如果是最后1个数字，仍然可以执行运算，也就是非数字且非空格符整体和是最后一个数字，2个条件是或的关系。

## 验证是否为回文字符串

字符串s是非空的，删除1个字符能让它成为回文字符串则返回真，否则返回假。

### enum解法

枚举解法是：判断是否为回文字符串，如果是就返回真；不是，则枚举每个位置，判断除了该位置以外的字符串是否为回文字符串。这种解法时间复杂度O(n^2)。

如何判断是否为回文的，定义双指针，分别指向开头和结尾，如果相等，则头指针+1，尾指针-1，如果不相等说明不是回文的。

上边的判断回文可以单独作为一个函数，主函数则是传递不同位置缺省时的字符串(包括不缺省的字符串)。

### greedy解法

贪心算法不再枚举每个位置，而是考虑2个字符不相等的时候。因为至多只能删除1个字符,所以2个字符之间必须删除1个。那么删除其中1个以后有2种可能：取[head,tail-1]的字符串或者[head+1,tail]的字符串，判断它们是否回文即可。如果至少有1个是回文的说明可以，否则就不可以，因为至多删除1次，后边也无需再比较。如果2个字符相等，就让head++，tail--即可，直到遇见不相等的时候 。

## Excel表列名称转列序号

### iteration解法

本质上就是进制转换问题，将26进制转换为10进制，例如，对于字符串"FXSHRXW"，其转换为10进制数的计算方法为

```c++
23×26^0+24×26^1+18×26^2+8×26^3+19×26^4+24×26^5+6×26^6=2147483647
```

注意要从右往左遍历每个字符，将其转换为数字，用这个数组乘26的幂即可，幂数恰好就是字符个数减去当前字符下标-1。

结论是：

```c++
number = Σ(i=0->n-1)ai * 26^i
```

## Excel表列序号转列名称

是上述问题的镜像问题

给定1个整数，根据映射关系得到Excel表的列名。

例如1对应"A"，2对应"B"，26对应"Z"，27对应"AA"，28对应"AB"，以此类推。

### iteration解法

根据上述镜像问题的结论，原来是已知每个数字ai，根据数字ai的位置就可转换到10进制数。

现在反过来，依据10进制数，依次计算每个ai，也就是10进制数转16进制数。

如何计算这些数字呢？

首先将a0分离，并同时减去1，变为

```c++
number-1 = a0-1+Σ(i=1->n-1)ai*26^i
```

因为0<=a0-1<=25，可以看出a0-1实际上就是number-1除26的余数，因为后边一项是26的公倍数。

即有

```c++
(number-1) % 26 = a0-1
```

也就是

```c++
a0 = (number-1) % 26+1
```

而a0又是计算a1的基础，有了a0可以计算a1

```c++
number-a0 = a1 * 26 + Σ(i=2->n-1)ai*26^i
```

两边同除26并减去1，可以得到a1的计算式

```c++
a1-1 = (number-a0)/26-1 - Σ(i=2->n-1)ai*26^i
```

a1其实就是，(number-a0)/26-1 除26剩下的余数。

```c++
a1 = ((number-a0)/26-1)%26+1
```

(number-a0)/26可以用新的number替换，依然具备形式

```c++
a1 = (number-1)%26+1
```

类似的

```c++
a2 = ((number-a1)/26-1)%26+1
```

(number-a1)/26可以用新的number替换，被替换为

```c++
a2 = (number-1)%26+1
```

## 字符串解码

### stack解法

比较困难暂时跳过。

### recursion解法

比较困难暂时跳过。

### iteration解法

个人给出的解法，缺陷在于不能够对嵌套型的[]进行解码，例如'3[a2[b]]'是不能解码为'abbabbabb'。

因为思路是先找到'['和']'，按照顺序遍历每个字符的，默认'['后边一定是']'。有了位置，就可以把中间的字符串根据heaf位置前边的数字来复制份数，将其插回原来的字符串。最后把字符串的'['、']'和数字删除就可以。

## 宝石与石头

一个字符串jewels代表石头中宝石的类型，另一个字符串stones代表拥有的石头。stones的每个字符代表了拥有的一种石头类型，现在的问题是想知道石头里有多少是宝石，字母区分大小写

例如，jewels = "aA", stones = "aAAbbbb"，那么石头里边有3个是宝石。

前提：jewels的字符都是唯一的。

### iteration解法

暴力迭代法，遍历字符串 stones，对于 stones 中的每个字符，遍历一次字符串 jewels，如果其和 jewels 中的某一个字符相同，则是宝石。

### hashSet解法

对于字符串 stones 中的每个字符，都需要遍历一次字符串 jewels，导致时间复杂度较高。如果使用哈希集合存储字符串 jewels 中的宝石，则可以降低判断的时间复杂度。如果字符在集合里就表示算1个宝石。

## 子域名计数

给定字符串，"9001 discuss.leetcode.com"，顶级域名为"com" ，二级域名为"leetcode.com"，最低一级为"discuss.leetcode.com"。当访问域名 "discuss.leetcode.com"时，同时也会隐式访问其父域名 "leetcode.com"以及"com" 。给你一个 计数配对域名 组成的数组，解析得到输入中每个子域名对应的计数配对域名 ，并以数组形式返回。这里的输出应当["9001leetcode.com","9001discuss.leetcode.com","9001 com"]。

### hashTable解法

这个解法C++不好实现，没有给出。java和python有字符串的spilit函数，所以好处理。
