## 解题思路

## 找到数组的最大和最小值

### iteration解法

用两个变量记录目前最大和最小的值索引，根据数组大小n的情况来决定返回。

如果n=0，什么都没有；n=1，则最大和最小索引都是0；

如果n>1，还要判断n的奇偶性，如果是奇数，则初始最大最小值索引都从0开始，循环起始点为1；如果是偶数，就先比较a[0]和a[1]的情况，然后大的那个索引为maxIndex，小的给minIndex，循环起始点为2；这样可以保证后边的元素总是两两成对，便于比较；

开始每2个元素一组进行比较，大的那个元素和a[maxIndex]去比较，小的那个元素和a[minIndex]去比较，必要的话更新maxIndex和minIndex的值，循环结束就可以得到结果。

### recursion解法

借助分而治之的思想，这个解法是反复二分数组，直到最小单元2个或1个元素的数组，也就是当n不等于2的时候就会持续下去。如果是2个元素，用2个变量分别记录更小和更大的元素；如果是1个元素，最小和最大都是1个元素。

如果首次进入，n为0就返回2个None；如果是再次进入的，因为二分后数组的奇偶性可能发生变化，所以数组长度可能是1，则最大最小值认为是a[0]，数组调整长度为a[1:]就是[]了，这时候应当直接返回最大最小值；同理，数组长度可能是2，则最大最小值为{a[0],a[1]}或{a[1],a[0]}，调整数组的长度为a[2:]也是[]，应当直接返回，这是递归真正的终止条件。

例如，先判断n不为0以后，假设a还有2个或3个元素。此时再判断a是否等于2，如果等于2，二分后就是2个包含1个元素的数组；如果等于3，1个数组1个元素，另1个数组2个元素。然后再次进入递归，就遇见上一段所说的递归终止条件，无论是1个元素还是2个元素都会直接返回，不会再递归入栈，会不断递归退栈。

这个方法的缺点是不知道索引最大最小值在数组的位置，因为数组每次二分这个索引值就不再是原来整个数组的真实索引值了，只是各自小数组的索引位置。如果想通过这一系列小数组的索引位置倒退原数组真实的索引位置，比较困难。

另外递归法的速度甚至慢于纯循环方法，更不比说上边优化过的循环方法，代码文件测试，10000000个元素的量级下，递归花费7.16s，纯循环花费4.9s，上述优化的循环方法花费3.77s。

## 两数之和

找到2个数等于指定的数，返回这两个数的索引。

### iteration解法

C++中可以使用双while循环使用迭代器遍历也可以使用双for循环遍历，前者速度更快一些168ms左右，后者304ms。

思想是从第1个数开始，暴力匹配剩余的数，如果两数之和满足则返回索引，否则从第2个数暴力匹配剩余的数，直到最后2个数。

如果到了最后1个数，直接返回{-1,-1}。

对于Python直接使用列表双for循环即可，大约2900ms。

时间复杂度：O(n^2），空间复杂度：O(1）

### hashTable解法

哈希表是一个带有关键字的表，类似于字典，存在关键字-值的映射关系。这样查找1个元素无需比较，那么两数之和问题就可以变为对于1个元素a，表中是否存在target-a的元素，如果有返回这个元素的关键字。且由于两数之和问题，有个假设条件，就是两个数是不相等的，例如对于8而言，假如nums有3、4、5，应当返回3、5的索引而不是2个4的索引。

那么只需要实现把数组的索引和值存入哈希表，需要1次循环存入数值对；然后再次遍历每个数组元素a[i]，考量表中是否存在target-a[i]，且返回的索引不能是i。

哈希表的速度很快，C++只有12ms，Python中哈希表就是字典，为32ms。

## 三数之和

给定数组找到所有3个数和为0的三元组。

因为给定的数组元素可以有重复的，所以元素值不能作为标签，所以也就不能利用两数之和的解法来找。

### iteration解法

将数组进行从小到大排序，然后在三重循环中得到的三元数组(a,b,c)总是可以保证a≤b≤c，但是即使如此也不能保证所有重复的三元组被去掉。因为同一重循环，相邻的两个元素重复就会造成三元组重复，为了避免这个问题，还要加限制条件，即后1个元素要大于前1个元素。

### doublePointers解法

这个解法相对于上述解法进行了优化，因为在a固定时，如果b比较大，那么c应当比较小才可能和为0，根据这个可以进一步去除不必要的循环。那么可以在第2重循环的基础上，定义指针c，c指向数组的右端，随着b的取值不同，找到1个合适的c，这样的c在a+b+c＞0时肯定是不存在的，所以可以让循环条件为a+b+c>0，否则c持续向左移动，这时再遍历b和c之间可能的元素，减少了一些不必要的迭代，不过也要注意c持续向左移动也不能小于b，但是c是可以退到b的，此时说明不会再有合适的c，就没必要再继续，因为当前的b不成立，下一次b只会更大，但c又是b后面的位置，所以c更大，那么永远不可能遇见合适的c，故2重循环使用的是break而不是continue。

C++实现88 ms，Python为768ms。





















