## 解题思路
[解题思路](#https://github.com/doocs/leetcode/blob/main/solution/0100-0199/0145.Binary%20Tree%20Postorder%20Traversal/README.md)

## 二叉树的前中后序遍历
以编号1、2、3、4、5、6、7的完全二叉树为例
         1
      2     3
    4   5  6  7
可以有两种方法直接写出遍历结果，分别从前往后和从后往前看。
前->后：

前序遍历：节点排序为根左右即123，然后在2和3的基础上也要满足根左右，所以是245和367，所以把4、5插到2右，6、7插到3右，得到1245367

中序遍历：节点排序为左根右即213，然后在2和3的基础上也要满足左根右，所以是425和637，把4、5插到2两边，6、7插到3两边得到4251637

后序遍历：节点排序为左根右即231，类似的可得到4526731

以上是自上而下逐个元素判断比较繁琐，可以整体判断。

如果是前序遍历，根1放在最前边，然后整体的左子树在中间，整体右子树在后边，每棵子树又可以按照相同的规则去放置，直到最后1级。对于245，显然2放在45前边，3也放在67前边，所以整体就是1 245 367

中序和后序遍历类似。

后->前：
    	虽然整体的思想提高了理解性，但是自上而下还是有些麻烦，是逐棵子树到逐个元素的方向去插入元素，所以可从最后一级具有孩子节点的左右子树来看。
前序遍历：

末端的左子树为245，末端右子树367，245整体是左子树应在右子树367前边，故245367，然后向上寻找1级，父节点1应在左子树前边，即1245367

 中序遍历：末端的左子树为425，末端右子树637，父节点在中间为4251637

 后序遍历：末端的左子树为452，末端右子树673，父节点在后边为4526731

### 递归解法
​	核心区别是保存节点值语句所在的位置，分别在前中后。

### 栈解法
前序和后序遍历是类似的，压栈都是根节点先入

前序遍历：根、右、左节点依次压栈，由于栈后入先出的机制，先pop的是根节点，然后是左节点，最后是右节点，那么出来的是根、左、右，得到的就是结果

后序遍历：根、左、右节点依次压栈，由于栈后入先出的机制，先pop的是根节点，然后是右节点，最后是左节点，那么出来的是根、右、左，反转，左右根得到的就是结果

中序遍历：先左节点依次压栈，更新当前节点为压入的节点。直到左节点为空时，出栈，更新节点为出栈的元素，先出的是最后1个左节点，打印它的值，然后更新当前节点为这个出栈节点的右节点，当前节点为空则继续出栈，不为空右节点入栈，当前节点又更新为左节点。如此反复，直到左节点为空且栈无元素的时候停止运行，任一条件不满足都会执行。

前序遍历步骤：
1.定义一个栈 stk,先将根节点压入栈
2.若栈不为空,每次从栈中弹出一个节点(根节点开始)
3.保存该节点的值
4.先把节点右孩子压入栈,接着把节点左孩子压入栈(如果有孩子节点)
5.重复 2-4 所以左孩子先出栈、右孩子后出栈
6.返回结果为根、左、右

后序遍历步骤：
1.定义一个栈 stk,先将根节点压入栈
2.若栈不为空,每次从栈中弹出一个节点(根节点开始)
3.保存该节点的值
4.先把节点左孩子压入栈,接着把节点右孩子压入栈(如果有孩子节点)
5.重复 2-4 所以右孩子先出栈、左孩子后出栈
6.返回结果为根、右、左，反转即得到左、右、根为后序遍历

中序遍历步骤：
1.定义一个栈 stk
2.将树的左节点依次入栈,更新root,直到左节点为空,此时root为空
3.root为空时,让root等于弹出的栈顶元素并保存,然后更新root为右节点
直到root不为空,也就是root上移才有可能,这时右节点也入栈,保存后root又更新为左节点
然后root又为空,root会继续更新为栈顶元素,如果栈顶元素也没有,循环退出
4.重复 2-3 的操作

### Morris解法
前序遍历：
1.最开始cur=root,如果cur无左孩子,将当前节点值保存,cur向右移动(cur=cur.right)
2.如果cur有左孩子,找到cur左子树上最右的节点,记为mostright
    2.1如果mostright的right指针指向空,将当前节点值保存,让其指向cur,cur向左移动(cur=cur.left)
    2.2如果mostright的right指针指向cur,让其指向空,cur向右移动(cur=cur.right)
3.cur为空时停止遍历

后序遍历：
1.最开始cur=root,如果cur无右孩子,cur向左移动(cur=cur.left)
2.如果cur有右孩子,找到cur右子树上最左的节点,记为mostleft
    2.1如果mostleft的left指针指向空,让其指向cur,cur向右移动(cur=cur.right)
    2.2如果mostleft的left指针指向cur,让其指向空,cur向左移动(cur=cur.left)
3.cur为空时停止遍历
<u>**后序和前序正好左右相反,其它基本一致,前序无需反转,后序需要反转</u>**

中序遍历：
1.最开始cur=root,若cur无左孩子,将当前节点值保存,cur向右移动(cur=cur.right)
2.如果cur有左孩子,找到cur左子树上最右的节点,记为mostright
  2.1如果mostright的right指针指向空,让其指向cur,cur向左移动(cur=cur.left)
  2.2如果mostright的right指针指向cur,将当前节点值保存,让其指向空,cur向右移动(cur=cur.right)
3.cur为空时停止遍历
中序遍历和前序遍历的程序完全相同，**<u>区别是前序在2.1保存值,后序是2.2保存值</u>**

## 二叉树的层次遍历

### queue解法

定义一个指针t指向root，进入while循环，t不为空时保存t的值，然后将t的左、右节点依次入队列，然后尝试获取队列的首元素，队列为空时会抛出异常退出while，否则更新t指向队列首元素，然后判断t是否为空，是继续while否则退出得到结果。

上述解法遇到节点元素没有值的情况是不会打印的。

为了解决有None也打印，可以函数多加1个参数height，需要知道树的高度,否则会无穷尽的打印None，因为他不知道什么结束循环，所以规定只打印pow(2,height)-1这么多元素，超出的其实都是None但不会打印。

C++目前为止，作者无法实现第2种层次遍历方法的打印，因为nullptr不同于node，无法在while循环遍历。

### deque解法



## 判断是否为平衡二叉树

### 递归解法

考虑最小二叉树单元，根、左、右节点应当满足的情况。

左节点和右节点都为空，说明平衡；

左节点和右节点只有1个不为空，或者都不为空时但是值不相等，说明不平衡。

然后再考虑稍大一点的二叉树单元，左节点继续有左右节点，右节点也有左右节点。

如果依然需要平衡，那么应当左节点的左节点和右节点的右节点也要满足上述最小单元条件，即都为空或者都不为空且值相等，同时左节点的右节点与右节点的左节点也是如此。

推广二叉树单元，随着级的增加，总是要满足left.left与right.right、left.right与right.left，所有可以抽象出1个递归函数，起始点为root.left和root.right，带入这个函数，再把这两个看成新的left和right，内部嵌套递归，所有的节点都会这样比较下去，这就是判断是否平衡二叉树的思路。

### 数组迭代解法

本解法基于二叉树的层次遍历，事先得到映射的数组，然后对数组观察规律，发现比较[2^i,2^(i+1)-1]之间的树是否对称即可。例如i=2，就是比较[4,7]之间的4个元素；i=3，就是比较[8,15]之间的8个元素，前提也是需要知道树的高度。

因为C++的第2种层次遍历方法无法实现，所以失去了返回数组的基础

那么也就无法使用数组的方法去判断是否为平衡二叉树，目前Python可以实现

