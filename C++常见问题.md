## 什么是命名空间

命名空间是一种将库名称封装起来的办法，通过这种方法可以避免和应用程序发生命名冲突的问题。例如想使用cin和cout对象需要包含头文件< string >和< iostream>的同时，必须使用标准命名空间std。

## ++i和i++的区别

如果是单独的语句，并没有区别。得到的结果是一样的。在for循环中i++和--i作为expression也是没有区别的，因为expression是循环结束后计算出来，最后结果不会改变。

不过i++语句是需要一个临时变量取存储返回自增前的值，而++i不需要。这样就导致使用i++时系统需要先申请一段内存空间，然后将值塞进去，最后不用了才去释放。

```c++
i++;
--j;
```

如果是表达式，就会有所区别。i++是表达式先用i的值，再让i自增，所以n的值为1；++j是先把j增加1，所以表达式的值变为2，故m=2。

```c++
int i,j = 1;
int n = i++;
int m = ++j;
```

## static的修饰作用

①修饰局部变量：该变量在**静态存储区**分配内存，只能在首次函数调用中进行首次初始化，之后的函数调用不再进行初始化；其生命周期与程序相同，**但其作用域为局部作用域**，并不能一直被访问；
②修饰全局变量：该变量在**静态存储区**分配内存；在声明该变量的整个文件中都可见，文件外不可见；
③修饰普通函数：在声明该函数的整个文件中可见，文件外不可见，可在多人协作时避免同名函数冲突；
④修饰成员变量：所有类对象都只维持一份拷贝，可以实现不同对象间数据共享，无需实例化对象即可访问；不能在类内部初始化，一般在类外部初始化，并且初始化时不加static；
⑤修饰成员函数：该函数不接受this指针，只能访问类的静态成员，无需实例化对象即可访问。

## extern变量的使用

分3个情况来说明：

① 外部变量在本文件定义：该全局变量的作用域从变量的定义开始到文件末尾，如果在定义之前有函数引用了这个全局变量，就会报未定义标识符的错误，所以可在调用之前先声明这个变量为外部的，那么编译器就会优先从本文件去寻找，如果没找到，会在同一目录下的文件寻找。全局函数和全局变量的含义类似，如果在调用前没有声明过也会报错，同样可以使用extern+函数原型的办法去声明，本文件找不到就去其他文件寻找。

② 外部变量在其他文件定义：假如A文件定义了全局变量a=10，在B文件声明a为外部变量后，打印a的值就是10，优先从B文件寻找没找到就会从其它文件寻找，在A文件可以找到。但是B文件不能再次定义a=5，无论在B文件的哪个位置定义，记住定义只能有一次。

③ 外部变量在头文件定义：唯一的区别是，因为头文件可以被多次包含，这个外部变量可以在任何文件中被首次定义，但是一经定义，其他文件不能够再定义，只能够使用。所以如果非必要，不是常量表达式/数组的话不要在头文件中定义全局变量/外部变量。

## 宏定义的作用

① 宏定义可用宏代替一个在程序中经常使用的常量，常量需要修改时可以只修改宏，方便修改；

② 使用带参数的宏定义可完成函数调用的功能，减少系统开销，提高运行效率；

③ 宏定义在预处理阶段即进行了宏展开，在执行时不需要转换，可以当地执行。函数的话在调用时需要先保留现场，执行完毕后再回到现场，如果函数的功能比较简单，则离开-回到现场的花费时间可能大于函数本身执行花费的时间，宏定义不会，直接执行；

④ 宏定义相对于const常量来说，在编译阶段无法执行变量类型检查，在编译时就将定义的变量全部替换，可能会有安全问题；

⑤ 宏定义没有内存开销，仅仅是编译时期替换，不能取地址；const常量则是运行时期的变量，类型不匹配会检查出来，需要分配内存，可以取地址；

⑥ 宏定义有括号边界效应，因为宏定义的时候，各个分量未加括号，传递的参数是变量表达式，系统展开后可能由于括号优先级的问题结果不一定是正确的。

例如，在头文件定义了宏函数。

```c++
#define MUL(A,B) A*B
```

使用宏时，代码文件传入了这样的参数。

```c++
int a=1,b=2,c=3,d=0;
d=MUL(a+b,c)
```

实际上编译过程展开为

```c++
d=a+b*c
```

这时传入的是表达式，并没有把括号一起传进去

解决方法是给每个分量都加上括号，就可以避免此类问题

```c++
#define MUL(A,B) ((A)*(B))
```

再如，宏定义一个结构体指针类型，结尾没有分号。

```c++
#define dps struct s *
```

使用的时候，如下

```c++
dps p1,p2;
```

编译阶段实际展开为

```c++
struct s * p1,p2;
```

因为宏定义只是单纯的替换dps，这样p2就是普通的结构体类型，而不是指针类型了。

这种解决方法是不使用宏定义，而是使用别名typedef，注意是有分号的。

```c++
typedef  struct * dps ;
```

⑦ 宏定义加了括号也不一定保证结果正确；

例如，宏定义比较函数。

```c++
#define MIN(A,B) ((A)<(B)?(A):(B))
```

调用宏。

```c++
int a=1,b=3,min=0;
min=MIN(a++,b);
```

经过编译替换展开后，就成了

```c++
min=((a++)< (b)?(a++):(b));
```

先计算a++的表达式为1，计算逻辑表达式1<3是成立的，此时a已经为2，然后返回的是a++，等号右侧结束运算，a变成了3，并不是想要的结果1。

解决方案是使用template inline函数替代宏函数。因为这里的MAX是真正的函数，它遵守作用域和访问规则，还可以进行类型检查，还可以写出限制在class内的私有inline函数，而宏定义是无法做到的。

```c++
template<typename T>
inline T MAX(const T&x, const T&y){
    return x+y;
}
```

