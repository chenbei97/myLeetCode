## 解题思路
[解题思路](#https://github.com/doocs/leetcode/blob/main/solution/0100-0199/0145.Binary%20Tree%20Postorder%20Traversal/README.md)

## 二叉树的前中后序遍历
以编号1、2、3、4、5、6、7的完全二叉树为例
         1
      2     3
    4   5  6  7
可以有两种方法直接写出遍历结果，分别从前往后和从后往前看。
前->后：

前序遍历：节点排序为根左右即123，然后在2和3的基础上也要满足根左右，所以是245和367，所以把4、5插到2右，6、7插到3右，得到1245367

中序遍历：节点排序为左根右即213，然后在2和3的基础上也要满足左根右，所以是425和637，把4、5插到2两边，6、7插到3两边得到4251637

后序遍历：节点排序为左根右即231，类似的可得到4526731

以上是自上而下逐个元素判断比较繁琐，可以整体判断。

如果是前序遍历，根1放在最前边，然后整体的左子树在中间，整体右子树在后边，每棵子树又可以按照相同的规则去放置，直到最后1级。对于245，显然2放在45前边，3也放在67前边，所以整体就是1 245 367

中序和后序遍历类似。

后->前：
    	虽然整体的思想提高了理解性，但是自上而下还是有些麻烦，是逐棵子树到逐个元素的方向去插入元素，所以可从最后一级具有孩子节点的左右子树来看。
前序遍历：

末端的左子树为245，末端右子树367，245整体是左子树应在右子树367前边，故245367，然后向上寻找1级，父节点1应在左子树前边，即1245367

 中序遍历：末端的左子树为425，末端右子树637，父节点在中间为4251637

 后序遍历：末端的左子树为452，末端右子树673，父节点在后边为4526731

### recursion解法
核心区别是保存节点值语句所在的位置，分别在前中后。

### stack解法
前序和后序遍历是类似的，压栈都是根节点先入

前序遍历：根、右、左节点依次压栈，由于栈后入先出的机制，先pop的是根节点，然后是左节点，最后是右节点，那么出来的是根、左、右，得到的就是结果

后序遍历：根、左、右节点依次压栈，由于栈后入先出的机制，先pop的是根节点，然后是右节点，最后是左节点，那么出来的是根、右、左，反转，左右根得到的就是结果

中序遍历：先左节点依次压栈，更新当前节点为压入的节点。直到左节点为空时，出栈，更新节点为出栈的元素，先出的是最后1个左节点，打印它的值，然后更新当前节点为这个出栈节点的右节点，当前节点为空则继续出栈，不为空右节点入栈，当前节点又更新为左节点。如此反复，直到左节点为空且栈无元素的时候停止运行，任一条件不满足都会执行。

前序遍历步骤：
1.定义一个栈 stk,先将根节点压入栈
2.若栈不为空,每次从栈中弹出一个节点(根节点开始)
3.保存该节点的值
4.先把节点右孩子压入栈,接着把节点左孩子压入栈(如果有孩子节点)
5.重复 2-4 所以左孩子先出栈、右孩子后出栈
6.返回结果为根、左、右

后序遍历步骤：
1.定义一个栈 stk,先将根节点压入栈
2.若栈不为空,每次从栈中弹出一个节点(根节点开始)
3.保存该节点的值
4.先把节点左孩子压入栈,接着把节点右孩子压入栈(如果有孩子节点)
5.重复 2-4 所以右孩子先出栈、左孩子后出栈
6.返回结果为根、右、左，反转即得到左、右、根为后序遍历

中序遍历步骤：
1.定义一个栈 stk
2.将树的左节点依次入栈,更新root,直到左节点为空,此时root为空
3.root为空时,让root等于弹出的栈顶元素并保存,然后更新root为右节点
直到root不为空,也就是root上移才有可能,这时右节点也入栈,保存后root又更新为左节点
然后root又为空,root会继续更新为栈顶元素,如果栈顶元素也没有,循环退出
4.重复 2-3 的操作

### Morris解法
前序遍历：
1.最开始cur=root,如果cur无左孩子,将当前节点值保存,cur向右移动(cur=cur.right)
2.如果cur有左孩子,找到cur左子树上最右的节点,记为mostright
    2.1如果mostright的right指针指向空,将当前节点值保存,让其指向cur,cur向左移动(cur=cur.left)
    2.2如果mostright的right指针指向cur,让其指向空,cur向右移动(cur=cur.right)
3.cur为空时停止遍历

后序遍历：
1.最开始cur=root,如果cur无右孩子,cur向左移动(cur=cur.left)
2.如果cur有右孩子,找到cur右子树上最左的节点,记为mostleft
    2.1如果mostleft的left指针指向空,让其指向cur,cur向右移动(cur=cur.right)
    2.2如果mostleft的left指针指向cur,让其指向空,cur向左移动(cur=cur.left)
3.cur为空时停止遍历
<u>**后序和前序正好左右相反,其它基本一致,前序无需反转,后序需要反转</u>**

中序遍历：
1.最开始cur=root,若cur无左孩子,将当前节点值保存,cur向右移动(cur=cur.right)
2.如果cur有左孩子,找到cur左子树上最右的节点,记为mostright
  2.1如果mostright的right指针指向空,让其指向cur,cur向左移动(cur=cur.left)
  2.2如果mostright的right指针指向cur,将当前节点值保存,让其指向空,cur向右移动(cur=cur.right)
3.cur为空时停止遍历
中序遍历和前序遍历的程序完全相同，**<u>区别是前序在2.1保存值,后序是2.2保存值</u>**

## 二叉树的层次遍历

### queue解法

#### 返回展平的层遍历

定义一个指针t指向root，进入while循环，t不为空时保存t的值，然后将t的左、右节点依次入队列，然后尝试获取队列的首元素，队列为空时会抛出异常退出while，否则更新t指向队列首元素，然后判断t是否为空，是继续while否则退出得到结果。

上述解法遇到节点元素没有值的情况是不会打印的。

为了解决有None也打印，可以函数多加1个参数height，需要知道树的高度,否则会无穷尽的打印None，因为他不知道什么结束循环，所以规定只打印pow(2,height)-1这么多元素，超出的其实都是None但不会打印。

思路：上述不打印null的是控制t不为空才会入列,且t的左右子树不为空才会入列，因为入列的是根、左、右，每次t更新又变成左节点，因为左节点先入，这样可以保证每层总是从左到右依次遍历节点。不过上边的函数是为空就不会再入列了，所以碰到空节点无法打印。为了解决这个问题，循环不再是t不为空来控制，相反无论t是否为空都入列，只是下次t更新时如果是空节点,说明它左右节点必然也是空节点，所以直接让队列添加2个空指针即可。相应的t是空节点则ans保存指定的值value=-1，-1是指定的一个数，value可以是任何数，因为这个函数本来目的是为了平衡二叉树的验证来使用。python中的实现因为None也可以被打印出来,所以无需指定1个数,直接打印None即可。如果一个二叉树遍历出来有很多-1，无论是二叉树本来有的数据-1还是因为nullptr而指定的-1，都不会改变原本二叉树是否平衡的结论。本函数的while循环不通过t控制，而通过q是否为空来控制，但是因为nullptr也可以入列，那么任意一个二叉树如果把nullptr可以当成节点的话就有无穷多个nullptr，所以需要引入二叉树的高度限制,通过高度可以知道二叉树应该有的元素个数。最多遍历到有至少1个非空节点的层，再后面就不再打印，因为没有意义。

#### 返回嵌套的层遍历

提供了，返回None和不返回None的写法，返回的结果每层是一个列表

核心思路：while循环条件是队列不为空，只要队列不为空，每次队列更新添加进的元素就是整个层的元素。所以可以在队列更新后，先得到队列的大小，即元素个数，然后遍历当前更新的队列，依次取出元素的值就可以，放到临时变量t，然后t再被ans添加。

无论带不带None，while循环条件没有变化，区别在于，更新q前者是为None的节点不添加，后者无论是否为None都添加。且判断的是root是否为None，如果它是，2个子树直接添加2个None即可，不是，他左右子树是不是None都无所谓直接添加。

### deque解法

deque解法和queue的解法思路完全相同，只是pop和front函数不同

对于python，from collections import deque，返回并删除队首元素为popleft函数，而queue是from queue import Queue，其函数为get_nowait和put_nowait函数

对于c++，front函数和queue一致，删除队首queue是pop，deque是pop_front函数

唯一要注意的地方和queue实现一样，就是打印None或者null节点信息的函数要注意先判断是不是null，不是则插入2个左右节点，否则插入2个空指针，然后while循环的控制条件是对于嵌套的列表是展平后的元素为pow(2,height)-1退出循环。

## 判断是否为平衡二叉树

### recursion解法

考虑最小二叉树单元，根、左、右节点应当满足的情况。

左节点和右节点都为空，说明平衡；

左节点和右节点只有1个不为空，或者都不为空时但是值不相等，说明不平衡。

然后再考虑稍大一点的二叉树单元，左节点继续有左右节点，右节点也有左右节点。

如果依然需要平衡，那么应当左节点的左节点和右节点的右节点也要满足上述最小单元条件，即都为空或者都不为空且值相等，同时左节点的右节点与右节点的左节点也是如此。

推广二叉树单元，随着级的增加，总是要满足left.left与right.right、left.right与right.left，所有可以抽象出1个递归函数，起始点为root.left和root.right，带入这个函数，再把这两个看成新的left和right，内部嵌套递归，所有的节点都会这样比较下去，这就是判断是否平衡二叉树的思路。

### iteration解法

本解法基于二叉树的在空节点位置可以返回None或者某个指定的数值的层次遍历，事先得到映射的数组，然后对数组观察规律，发现比较[2^i,2^(i+1)-1]之间的树是否对称即可。例如i=2，就是比较[4,7]之间的4个元素；i=3，就是比较[8,15]之间的8个元素，前提也是需要知道树的高度。要求可以返回None或者指定数值，是为了不影响数组符合的长度规律，否则无法判断。

## 判断一棵树是否另一棵树子树

使用递归和迭代，C++和Python都给予了实现。

### iteration解法

迭代解法相对简单，需要2个函数。第1个函数负责找到从tree1中找到所有和tree2首元素相等的节点，可以是同级的相等节点，也可以是错位级的相等节点。第2个函数找到这个节点以后判断以这个节点为根节点的子树是否包含第2棵树。

本方法是基于层次遍历事先记录好节点的指针，这个解法相比与递归减少了很多空间复杂度，优化了。

### recursion解法

递归法，loop会被(tree1,tree2)、(tree1.left,tree2)、(tree2.right,tree2)调用，分别记作a、b、c调用。

(tree1,tree2)调用：

第1次进入时如果是r1,r2,均不为空且相等已满足,直接就进入下一次调用

如果均不为空但是不相等返回false?应当尝试r1的下一个节点和r2

即r1.left和r2.left and r1.right和r2.right的比较 相当于进入相等的节点下一级,比较是否各自对应相等

能够再次进入下次调用说明下一级的所有节点2棵树确实相等,那就需要比较下下级，如此类推

直到r2结束,一般是第1棵树层次大于等于第2棵树,如果r2为空,说明第1棵树存在这样的子树

如果r2还没结束,r1先结束就返回false,不存在这样的子树

 (tree1.left,tree2)调用：

第1次进入r1.left和r2时,r2肯定不为空,r1.left可能为空也可能不会;

如果r1.left为空,说明第1棵树已经结束,但r2没结束,不存在这样的子树

如果r1.left不为空,比较值是否相等,如果相等,第1棵树的这个节点是和r2相等的,只是不在一个层

那么就进入下一次递归,对2棵树错位级的所有节点进行比较,即第1棵树的下一级和第2棵树的当前级所有节点比较

后面思路类似,直到r2结束,如果r2先结束说明存在这样的子树,r1先结束不存在这样的子树

 都没结束就进入第1棵树的下下级和第2棵树的下级所有节点的比较

 (tree2.right,tree2)调用：

第1次进入r1.right和r2时,和第1次进入r1.left和r2的情况一样,都是2棵树错位级的所有节点进行比较

容易爆栈，python运行不了，C++也不行

## 合并两棵左高树

左高树的前提是父节点的值不小于子节点，同时同一父节点下，左节点的编号值不小于右节点的编号值。

### recursion解法

利用递归反复交换基准树的右子树和非基准树，必要的话交换基准树的左右子树。

目前使用了C++实现，Python因为没有指针的引用这种概念，同样的循环无法真实的交换root1.right和root2。

尝试进行解决，目前暂时没找到方法(2022.2.18)，所以先跳过。

解决了Python递归不能更新全局的root1的问题，改动是返回每次递归更新的r1和r2，并用全局的root1.right和root2去接收，最后也要返回root1和root2就可以了，思路来源于合并2棵二叉树的Python代码。(2022.2.20)

## 合并两棵普通二叉树

合并规则是，2棵二叉树相同位置的节点如果均不为空，就把2个节点的值相加；如果有1个为空，就把非空的节点作为新节点合并；如果均为空，什么也不做。

### recursion解法

先判断root2，为空直接返回无需操作，对于Python需要返回root1；再判断root1，如果为空，则让root1=root2即可，对于Python也要返回。然后就剩下2个均非空的情况，直接让root1.val+root2.val即可，然后继续递归root1.left和root2.left以及root1.right和root2.right，这两个先更新left和right都没问题。Python的写法要注意递归返回的值去更新原来的root1的left和right。

### stack解法

栈的解法，先判断是否各自为空，然后把2棵树的根节点分别入栈。以基准树的栈不为空为条件，总是获取栈顶元素并删除，把第2棵树节点的值加到基准树上。然后判断这个节点的左右节点情况，如果是基准树的左节点为空，则交换基准树与非基准树的左节点，否则继续判断是不是都不为空，如果均不为空，直接把这两个左节点各自入栈，如果不是，不需要做什么。基准树与非基准树的右节点也是如此，同理，左右节点的判断顺序不会影响结果。

注意Python的实现可以借助列表[]

### queue解法

因为左右节点的判断顺序不会影响结果，所以用queue替换stack也是ok的。Python使用队列时while循环条件不能用while s1，只能用while not s1.empty()，否则抛出队列空的异常。初始化2个队列时也要注意，必须s1,s2 = Queue(),Queue()初始化，再push2个root，而不能s1,s2=Queue(root1),Queue(root2)，否则while循环出错。stack解法则是可以s1,s2=[root1],[root2]的。

## 判断是否为完全二叉树

### queue解法

从根开始，如果两个孩子均不为空节点就可以放入队列货架；如果左节点为空右节点不为空，必然不是完全二叉树；如果左右都为空节点，或者左节点不为空右节点为空，那就可能是完全二叉树。

如果左节点不为空，右节点为空，就把左节点放入队列，然后删除这个节点。在它之后，所有队列的节点都应当是空节点，否则就不是完全二叉树；判断结束后，没有返回false，就说明是完全二叉树。

C++和Python都给予了实现。

## 翻转二叉树

### recursion解法

根节点进入函数，先判断是不是为空，为空就返回；如果不为空，交换根节点的左右节点，把左节点和右节点分别再次递归。先左后右和先右后左都不影响结果。

### queue解法

根节点进入函数，先判断是不是为空，为空就返回；如果不为空，把根节点放到队列，当队列不为空的时候，就获取队列的首元素，然后交换首元素的2个节点，删除这个首元素。然后把首元素的2个节点（如果不为空的话）就放入队列。

### stack解法

和queue的解法一样，只是处理的时候，后入先出。队列的话会先处理右节点再处理左节点，栈是相反的。但是左右顺序不影响结果。

特别的在Python里边可以把列表看成栈，因为pop函数可以指定删除的元素位置，但是默认是删除队尾元素的，所以要指定索引为0。

## 二叉树的右视图

右边看二叉树，返回所能看到的节点。

### queue解法

本质上是层序遍历，然后取每层的最后1个元素。由于需要控制在每一层的最后去实施这样的操作，方法上就和返回嵌套列表的层序遍历相似，区别在于是让右节点先入列然后左节点，这样可以保证队列的首元素实际上是层元素的最后1个，因为不需要每个元素都获取，所以是在for循环外让ans添加队首元素，即是右视图，而不是在for循环内，那样就是嵌套列表的写法了。

如果是左视图呢？那就先入队列的是左节点，然后右节点，ans依然在for循环外获取队首元素。

## 打印二叉树所有路径

### recursion解法

先判断root是否为None，是就返回，不是就把这个节点添加到临时的路径变量path，如果左右节点均为None时，说明一条路径结束，将path添加进总路径变量paths。之后如果左右节点不为空的话，会继续递归该节点的左右节点。

对于Python的实现借助了列表，paths和path都是列表。每到1个节点就分出2个路径，右节点优先，左节点压栈，直到2个子节点都是空为止，paths就存储1条路径。因为左节点压栈的过程中，path的pop过程也是被压栈，所以先执行path的退栈，压栈次数和节点压栈次数相同，结果就是退回全局根节点。然后再执行当初被压栈的左节点，过程相同。

对于C++要拆成2个函数，第1个调用函数allPaths，第2个函数findPaths是递归的函数，全局变量paths是私有属性，vector< string >类型，递归结束后路径都会存放在paths当中。而path是string类型，因为string+="->"，如果类似Python的写法会出错，因为string把"-"，"->"都会看成1个字符串，或者"10"会只删除1个1，就会出错。findPaths函数没有借助pop的压栈过程，原因就是上述说明的原因。解决方法是，每次到达1个节点分出2个路径都是以这个节点的path为基础再继续下一轮递归。这样相当于左节点和右节点各自都拥有一个path，path存储的是到它们父节点为止的路径，然后这两个左右节点会继续分裂，同样path更新后作为它们各自左右节点的基础。直到分裂的2个节点均为空节点，直接返回，不需要退栈，可以认为是线程分裂，每分裂一次线程加倍，各自到达后直接返回即可，所以没有对path变量的pop以便于复用的过程，每个同级别的线程都有1个path。

### stack解法

以一个简单的例子说明思路

​             1

​         /      \

​      2           3

​    /

4

首先p指向全局根节点1，先找到最左路径。因为p不为空，路径添加它，然后更新p指向左节点2，路径添加它，循环直到左节点为空为止，也就是节点4，就会退出循环；

此时如何判断1、2、4是最终的路径呢，退出循环是因为碰到4的左节点null，如果是最终路径，其兄弟节点应当也是空节点，否则并不是最终路径；

此时的路径栈存放的是1、2、4，所以让p指向栈顶元素也就是4，路径出栈此时为1、2，然后判断条件是否成立，如果此时p的右节点为空就添加路径，因为4的右节点确实为空，所以添加它；为空的话可能节点2会有分叉，虽然这个案例没有，那么应当继续返回上一个父节点，也就是重复更新p指向栈顶元素2，再次退栈，此时路径为1，极端的情况下，2的右节点依然是空的，也就是本案例，就会重复直到1的右节点不为空才会进入寻找最左路径的过程。此时p=1，path="1"，因为所以会更新为p=3，path="1->3"，然后路径存储这个节点3，此时只有唯一的1个节点；

然后p指向路径的栈顶元素，还是3没变化，但是路径会退栈，因为3的右节点确实为空，所以会记录这条路径，然后p=null更新，交由下一次while判断。此时p为空且栈已经为空，退出循环，程序结束。

如果4的右节点不为空呢，交由下一次while判断，类似于1的右节点为3不为空，更新p为新的右节点即可。

## 计算二叉树最大深度

### recursion解法

又分为2种解法，官方提供的解法是设定2个全局变量l、r记录左右子树的深度。首先判断父节点是否为空，是返回0，否则递归左节点和右节点，先后顺序无所谓，**<u>但是要注意不要多加条件，即不为空的时候才递归这个条件要删除，否则比较的左右节点可能不属于同一个父节点造成比较错误</u>**。一个节点只要不为空，就会分裂，它的两个子节点又作为父节点继续判断，堆当前节点而言，它的两个方向总是返回更深的那个值(但是这个过程先压栈)；两个子节点中不为空的节点可以继续分裂，返回以这个节点2个方向更大的那个深度，但是返回过程仍然继续压栈，直到路径到叶子节点为止，返回过程要进行退栈，根据当初先压左节点还是右节点来决定是先退右节点的返回过程还是左节点的返回过程，不过先后顺序本身不会影响结果。假如最早是先递归左方向，那么先退右方向的最晚入栈的右节点，必然是返回0的，然后退右方向稍晚其次入栈的左节点，必然也是返回0的，那么全局变量l和r均为0；然后退这两个节点的父节点，这个父节点必然不是空的，因为l不大于r，所以返回r+1，此时(l,r)=(0,1)，或者说选取2个中最大的深度+1，即1+max(l,r)=1，因为此时的0和0代表两个子节点子树的深度；如果这个父节点有兄弟节点，就会退兄弟节点的右子节点，然后退兄弟节点的左子节点，(l,r)会有变化，但是最终兄弟节点的返回值代表了兄弟节点子树的最大深度；然后兄弟节点和当前父节点会继续比较，选择更大的那个作为这两个父节点的父节点的返回值；以此类推，直到回到全局根节点，就会去退左方向的那些子节点，也是按照先右后左再根的过程。

最大节点的找法是从叶子节点开始,总是返回以这个节点为根节点的左右子树最大深度+1，显然叶子节点左右子树深度是(0,0),那么该节点返回值是1，然后该节点的相邻兄弟节点也返回了1个值,这2个节点的最大值再+1作为它们的父节点返回值，依次类推直到全局根节点,就可以得到最大深度。

<u>**核心：每个节点返回的值总是代表了以它为根节点的所有子树最大的那个深度，只是这个深度是从叶子节点一路到节点子树不断比较返回的而已**。</u>

个人还提供了一种递归方法，设定1个全局变量depth记录深度，一个局部变量d记录动态变化的深度。一开始，全局根节点为空就直接返回0，否则depth+1，然后把root和depth=1送入递归函数。递归函数内，如果左子树和右子树均为空，说明该路径递归结束，比较d和depth的关系，比depth大的话就让depth=d，然后返回，否则直接返回；如果不是均为空的情况，必然深度会+1，所以d++，然后递归当前节点的左右节点，并把当前的d作为一个基础传进去继续动态增加；这里可以加一个判断，不为空才递归可以减少不必要的计算，第1种递归方法就不能加判断。这些过程，可以理解为，每次遇到非空节点，只要它的子节点不是都为空就让d++，然后去和depth比较，每个同一父节点的左右节点的d都是相同的，可以看成多线程同时和一个全局变量比较。

### stack解法

思路来源于打印二叉树的所有路径，只需要把当前路径path改为d即可，当p==root就让d=1，否则就持续++。判断子节点均为空时，还要加个条件，如果d比depth大才会让depth=d，否则不变。

## 计算二叉树最小深度

### recursion解法

第1种递归方法是官方解法。从叶子节点开始,总是返回更小的那个，因为都是(0,0)，所以叶子节点返回值必定是1；叶子节点的父节点呢？取决于兄弟节点的情况，如果兄弟节点不为空，毫无疑问兄弟节点深度只可能大于等于叶子节点深度，所以应当返回叶子节点的深度+1，叶子节点可以是左节点也可以是右节点，但是不管是哪种都是返回另一个节点的深度+1，于是有下方2行代码

```c++
if (!root->left) return 1+treeMinDepth(root->right); // 总是返回兄弟节点的深度+1
if (!root->right) return 1+treeMinDepth(root->left);
```

但是也可能遇见2个节点均为空的情况，if(!root) return 0;已经涵盖这个情况。最后返回的是全局根节点的2个左右节点子树中深度更小的那个值。

第2种递归方法和计算最大深度的自定义方法类似，只是当节点的左右节点均为空时不再比较d和depth的大小然后更新depth，这样目的是为了保证depth总是最大的。因为找到最小的，所以这里只需要满足左右节点均为空时就记录这条路径的长度，最后返回所有长度最小值即可。但是要注意：初始的depth=1不要算上，否则总是1。

### stack方法

思路来源于计算二叉树的最大深度，将判断条件"如果d大于depth就让depth=d"去掉，用一个变量记录即可，最后计算变量元素的最小值就是最小深度。

## 二叉树路径总和

### recursion解法

方法和打印所有二叉树路径的题目相同，利用递归，终止条件是节点的左右节点都为空，说明一条路径结束，保存这个路径，然后执行退栈操作，这条路径返回到上一级，直到退回全局根节点为止。

如果节点的右节点或者左节点不为空，说明路径还可以持续，那就把右节点或左节点继续递归，直到遇见叶子节点。

### stack解法

栈的解法也参考打印所有二叉树路径的思路。

不过对于Python的实现，特别要注意，每次栈添加路径的时候，要添加路径变量的深拷贝。

比如原本变量pathSum是空，第1次pathSum添加了1，然后stk添加了pathSum，这还没问题
第2次变量pathSum又添加了2，stk添加了pathSum，这时stk并不是[[1],[1,2]]，而是[[1,2],[1,2]]，因为stk添加的pathSum是同一个地址，pathSum一旦变化，前边添加的也会变化，最终stk其实就是[pathSum,pathSum,pathSum,....]，所以需要深拷贝。

C++没有出现这样的问题，可能是因为pathSum是vector< int >类型，每次push_back以后和原来的pathSum地址不一样。

## 二叉搜索树中序迭代器

二叉搜索树具有如下性质：

- 结点的左子树只包含小于当前结点的数。
- 结点的右子树只包含大于当前结点的数。
- 所有左子树和右子树自身必须也是二叉搜索树

### stack解法

其实就是利用中序遍历的stack解法，用一个数组arr记录他，作为私有属性。类需要一个树节点初始化，然后数组记录的就是以这个树节点作为父节点的中序遍历。然后类有2个方法，一个是next方法，一个是hasNext方法，next可以返回中序遍历的下一个元素，hasNext可以判断是否存在下一个元素。所以还需要一个数组变量idx私有属性，实例化时初始为0，然后调用next就是arr[0]。

### recursion解法

递归解法就是改变了中序遍历的方式，其它没有变化。

Morris解法不再赘述。

## 二叉搜索树第k小元素

### inOrder解法

由于二叉搜索树的性质和中序遍历的含义，中序遍历的元素就是从小到大排列的。

自然根据中序遍历，可以有3种解法，stack、recursion和Morris解法。

不过上述解法都要遍历完整个二叉树，再去寻找第k小元素是可以的。

不过本解法是利用栈，找到最左边的节点以后，他也是最小的元素了，然后让k减1，直到k=0时，也就是第k小了，直接退出。

### iteration解法

通过记录子树的节点数实现。
