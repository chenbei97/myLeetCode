## 解题思路
[解题思路](#https://github.com/doocs/leetcode/blob/main/solution/0100-0199/0145.Binary%20Tree%20Postorder%20Traversal/README.md)

## 二叉树的前中后序遍历
以编号1、2、3、4、5、6、7的完全二叉树为例
         1
      2     3
    4   5  6  7
可以有两种方法直接写出遍历结果，分别从前往后和从后往前看。
前->后：

前序遍历：节点排序为根左右即123，然后在2和3的基础上也要满足根左右，所以是245和367，所以把4、5插到2右，6、7插到3右，得到1245367

中序遍历：节点排序为左根右即213，然后在2和3的基础上也要满足左根右，所以是425和637，把4、5插到2两边，6、7插到3两边得到4251637

后序遍历：节点排序为左根右即231，类似的可得到4526731

以上是自上而下逐个元素判断比较繁琐，可以整体判断。

如果是前序遍历，根1放在最前边，然后整体的左子树在中间，整体右子树在后边，每棵子树又可以按照相同的规则去放置，直到最后1级。对于245，显然2放在45前边，3也放在67前边，所以整体就是1 245 367

中序和后序遍历类似。

后->前：
    	虽然整体的思想提高了理解性，但是自上而下还是有些麻烦，是逐棵子树到逐个元素的方向去插入元素，所以可从最后一级具有孩子节点的左右子树来看。
前序遍历：

末端的左子树为245，末端右子树367，245整体是左子树应在右子树367前边，故245367，然后向上寻找1级，父节点1应在左子树前边，即1245367

 中序遍历：末端的左子树为425，末端右子树637，父节点在中间为4251637

 后序遍历：末端的左子树为452，末端右子树673，父节点在后边为4526731

### 递归解法
​	核心区别是保存节点值语句所在的位置，分别在前中后。

### 栈解法
前序和后序遍历是类似的，压栈都是根节点先入

前序遍历：根、右、左节点依次压栈，由于栈后入先出的机制，先pop的是根节点，然后是左节点，最后是右节点，那么出来的是根、左、右，得到的就是结果

后序遍历：根、左、右节点依次压栈，由于栈后入先出的机制，先pop的是根节点，然后是右节点，最后是左节点，那么出来的是根、右、左，反转，左右根得到的就是结果

中序遍历：先左节点依次压栈，更新当前节点为压入的节点。直到左节点为空时，出栈，更新节点为出栈的元素，先出的是最后1个左节点，打印它的值，然后更新当前节点为这个出栈节点的右节点，当前节点为空则继续出栈，不为空右节点入栈，当前节点又更新为左节点。如此反复，直到左节点为空且栈无元素的时候停止运行，任一条件不满足都会执行。

前序遍历步骤：
1.定义一个栈 stk,先将根节点压入栈
2.若栈不为空,每次从栈中弹出一个节点(根节点开始)
3.保存该节点的值
4.先把节点右孩子压入栈,接着把节点左孩子压入栈(如果有孩子节点)
5.重复 2-4 所以左孩子先出栈、右孩子后出栈
6.返回结果为根、左、右

后序遍历步骤：
1.定义一个栈 stk,先将根节点压入栈
2.若栈不为空,每次从栈中弹出一个节点(根节点开始)
3.保存该节点的值
4.先把节点左孩子压入栈,接着把节点右孩子压入栈(如果有孩子节点)
5.重复 2-4 所以右孩子先出栈、左孩子后出栈
6.返回结果为根、右、左，反转即得到左、右、根为后序遍历

中序遍历步骤：
1.定义一个栈 stk
2.将树的左节点依次入栈,更新root,直到左节点为空,此时root为空
3.root为空时,让root等于弹出的栈顶元素并保存,然后更新root为右节点
直到root不为空,也就是root上移才有可能,这时右节点也入栈,保存后root又更新为左节点
然后root又为空,root会继续更新为栈顶元素,如果栈顶元素也没有,循环退出
4.重复 2-3 的操作

### Morris解法
前序遍历：
1.最开始cur=root,如果cur无左孩子,将当前节点值保存,cur向右移动(cur=cur.right)
2.如果cur有左孩子,找到cur左子树上最右的节点,记为mostright
    2.1如果mostright的right指针指向空,将当前节点值保存,让其指向cur,cur向左移动(cur=cur.left)
    2.2如果mostright的right指针指向cur,让其指向空,cur向右移动(cur=cur.right)
3.cur为空时停止遍历

后序遍历：
1.最开始cur=root,如果cur无右孩子,cur向左移动(cur=cur.left)
2.如果cur有右孩子,找到cur右子树上最左的节点,记为mostleft
    2.1如果mostleft的left指针指向空,让其指向cur,cur向右移动(cur=cur.right)
    2.2如果mostleft的left指针指向cur,让其指向空,cur向左移动(cur=cur.left)
3.cur为空时停止遍历
<u>**后序和前序正好左右相反,其它基本一致,前序无需反转,后序需要反转</u>**

中序遍历：
1.最开始cur=root,若cur无左孩子,将当前节点值保存,cur向右移动(cur=cur.right)
2.如果cur有左孩子,找到cur左子树上最右的节点,记为mostright
  2.1如果mostright的right指针指向空,让其指向cur,cur向左移动(cur=cur.left)
  2.2如果mostright的right指针指向cur,将当前节点值保存,让其指向空,cur向右移动(cur=cur.right)
3.cur为空时停止遍历
中序遍历和前序遍历的程序完全相同，**<u>区别是前序在2.1保存值,后序是2.2保存值</u>**

## 二叉树的层次遍历

### queue解法

#### 返回展平的层遍历

定义一个指针t指向root，进入while循环，t不为空时保存t的值，然后将t的左、右节点依次入队列，然后尝试获取队列的首元素，队列为空时会抛出异常退出while，否则更新t指向队列首元素，然后判断t是否为空，是继续while否则退出得到结果。

上述解法遇到节点元素没有值的情况是不会打印的。

为了解决有None也打印，可以函数多加1个参数height，需要知道树的高度,否则会无穷尽的打印None，因为他不知道什么结束循环，所以规定只打印pow(2,height)-1这么多元素，超出的其实都是None但不会打印。

思路：上述不打印null的是控制t不为空才会入列,且t的左右子树不为空才会入列，因为入列的是根、左、右，每次t更新又变成左节点，因为左节点先入，这样可以保证每层总是从左到右依次遍历节点。不过上边的函数是为空就不会再入列了，所以碰到空节点无法打印。为了解决这个问题，循环不再是t不为空来控制，相反无论t是否为空都入列，只是下次t更新时如果是空节点,说明它左右节点必然也是空节点，所以直接让队列添加2个空指针即可。相应的t是空节点则ans保存指定的值value=-1，-1是指定的一个数，value可以是任何数，因为这个函数本来目的是为了平衡二叉树的验证来使用。python中的实现因为None也可以被打印出来,所以无需指定1个数,直接打印None即可。如果一个二叉树遍历出来有很多-1，无论是二叉树本来有的数据-1还是因为nullptr而指定的-1，都不会改变原本二叉树是否平衡的结论。本函数的while循环不通过t控制，而通过q是否为空来控制，但是因为nullptr也可以入列，那么任意一个二叉树如果把nullptr可以当成节点的话就有无穷多个nullptr，所以需要引入二叉树的高度限制,通过高度可以知道二叉树应该有的元素个数。最多遍历到有至少1个非空节点的层，再后面就不再打印，因为没有意义。

#### 返回嵌套的层遍历

提供了，返回None和不返回None的写法，返回的结果每层是一个列表

核心思路：while循环条件是队列不为空，只要队列不为空，每次队列更新添加进的元素就是整个层的元素。所以可以在队列更新后，先得到队列的大小，即元素个数，然后遍历当前更新的队列，依次取出元素的值就可以，放到临时变量t，然后t再被ans添加。

无论带不带None，while循环条件没有变化，区别在于，更新q前者是为None的节点不添加，后者无论是否为None都添加。且判断的是root是否为None，如果它是，2个子树直接添加2个None即可，不是，他左右子树是不是None都无所谓直接添加。

### deque解法

deque解法和queue的解法思路完全相同，只是pop和front函数不同

对于python，from collections import deque，返回并删除队首元素为popleft函数，而queue是from queue import Queue，其函数为get_nowait和put_nowait函数

对于c++，front函数和queue一致，删除队首queue是pop，deque是pop_front函数

唯一要注意的地方和queue实现一样，就是打印None或者null节点信息的函数要注意先判断是不是null，不是则插入2个左右节点，否则插入2个空指针，然后while循环的控制条件是对于嵌套的列表是展平后的元素为pow(2,height)-1退出循环。

## 判断是否为平衡二叉树

### 递归解法

考虑最小二叉树单元，根、左、右节点应当满足的情况。

左节点和右节点都为空，说明平衡；

左节点和右节点只有1个不为空，或者都不为空时但是值不相等，说明不平衡。

然后再考虑稍大一点的二叉树单元，左节点继续有左右节点，右节点也有左右节点。

如果依然需要平衡，那么应当左节点的左节点和右节点的右节点也要满足上述最小单元条件，即都为空或者都不为空且值相等，同时左节点的右节点与右节点的左节点也是如此。

推广二叉树单元，随着级的增加，总是要满足left.left与right.right、left.right与right.left，所有可以抽象出1个递归函数，起始点为root.left和root.right，带入这个函数，再把这两个看成新的left和right，内部嵌套递归，所有的节点都会这样比较下去，这就是判断是否平衡二叉树的思路。

### 数组迭代解法

本解法基于二叉树的层次遍历，事先得到映射的数组，然后对数组观察规律，发现比较[2^i,2^(i+1)-1]之间的树是否对称即可。例如i=2，就是比较[4,7]之间的4个元素；i=3，就是比较[8,15]之间的8个元素，前提也是需要知道树的高度。

因为C++的第2种层次遍历方法无法实现，所以失去了返回数组的基础

那么也就无法使用数组的方法去判断是否为平衡二叉树，目前Python可以实现

## 判断一棵树是否另一棵树子树

使用递归和迭代

### 迭代解法

迭代解法相对简单，需要2个函数。第1个函数负责找到两棵树元素值相同的节点，可以是同级的相等节点，也可以是错位级的相等节点。第2个函数找到这个节点以后判断以这个节点为根节点的子树是否包含第2棵树。

这个解法相比与递归减少了很多空间复杂度，优化了。

### 递归解法

递归法，loop会被(tree1,tree2)、(tree1.left,tree2)、(tree2.right,tree2)调用，分别记作a、b、c调用，这3个调用是为了找到是否有相同的节点，如果找到了，loop内部函数还会继续比较以这个节点为根节点的子树是否相等

容易爆栈，python运行不了，C++也不行

