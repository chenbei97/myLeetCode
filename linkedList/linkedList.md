<!--
 * @Author: chenbei
 * @Date: 2022-02-28 08:18:45
 * @LastEditTime: 2022-03-16 08:18:46
 * @Description: linkedList's leetcode analysis
 * @FilePath: \myLeetCode\linkedList\linkedList.md
 * @Signature: A boy without dreams
    -->

## 链表中间节点

如果是偶数个节点就返回第2个。

### iteration解法

链表的缺点在于不能通过下标访问对应的元素。可以考虑对链表进行遍历，同时将遍历到的元素依次放入数组 A 中。如果我们遍历到了 N 个元素，那么链表以及数组的长度也为 N，对应的中间节点即为 A[N/2]。

## singlePointer解法



## doublePointers解法



## 归并排序

### recursion解法

当题目输入的 head == None 或 head.next == None 时，直接返回head无需排序。

第一步，找到当前链表中点，并从中点将链表断开。具体做法：使用 fast,slow 快慢双指针法，奇数个节点找到中点，偶数个节点找到中心左边的节点。找到中点 slow 后，执行 slow.next = None 将链表切断。递归分割时，输入当前链表左端点 head 和中心节点 slow的下一个节点 tmp(因为链表是从 slow切断的)。递归终止条件，当head.next == None时，说明只有一个节点了，直接返回此节点。

第二步， 将两个排序链表合并，转化为一个排序链表。具体做法：双指针法合并，建立辅助ListNode h 作为头部。设置两指针left`, `right分别指向两链表头部，比较两指针处节点值大小，由小到大加入合并链表头部，指针交替前进，直至添加完两个链表。返回辅助ListNode h 作为头部的下个节点 h.next。

最后返回的结果，是h.next。

### iteration解法

第一步，不再使用递归，使用迭代的方式替换。分割环节本质上是通过二分法得到链表最小节点单元，再通过多轮合并得到排序结果。每一轮合并操作针对的单元都有固定长度intv，第一轮时链表已经二分到每个链表只有1个元素，所以intv=1，合并完就有2个元素了，所以第二轮链表长度为2，以此类推，直到intv大于等于链表长度代表已经完成排序。

所以有个新思路，反正都是要排序2个或者更多元素，排哪两个都一样，那么就取消分治递归过程。intv=1，就让第1和第2个元素，第3和第4个元素...各自比较即可。intv=2，让1,2合并的和3,4合并的比较 ，以此类推，直到intv大于等于链表长度。

所以增加1步：统计链表长度length，用于通过判断intv < length判定是否完成排序。

第二步，在每轮intv下的合并流程。根据intv找到合并单元1和单元2的头部h1, h2。由于链表长度可能不是2^n，需要考虑边界条件：找h2过程中，如果链表剩余元素个数少于intv，则无需合并环节，直接break，执行下一轮合并；若h2存在，但以h2为头部的剩余元素个数少于intv，也执行合并环节，h2单元的长度为c2 = intv - i。现在合并长度为c1, c2的h1, h2链表，合并完后，需要修改新的合并单元的尾部pre指针指向下一个合并单元头部h(合并单元尾部同时也作为下次合并的辅助头部pre)。当h == None，代表此轮intv合并完成，跳出。每轮合并完成后将单元长度×2，切换到下轮合并：intv *= 2。

## 两数相加I/II

I题是链表从头到尾的数字表示为一个数字的低位到高位，如6->4->1代表146。现在给定2个数字，要求计算返回和表示的链表。II题唯一的区别是，从头到尾的数组表示为高位到低位。

### iteration解法

I题的解法。

由于输入的两个链表都是逆序存储数字的位数的，因此两个链表中同一位置的数字可以直接相加。同时遍历两个链表，逐位计算它们的和，并与当前位置的进位值相加。具体而言，如果当前两个链表处相应位置的数字为 val1和val2，进位值为carry，则它们的和为 val1+val2+carry；其中，答案链表处相应位置的数字为 (val1+val2+carry)%10，而新的进位值为(val1+val2+carry)/10。如果两个链表的长度不同，则可以认为长度短的链表的后面有若干个 0。此外，如果链表遍历结束后，有carry>0，还需要在答案链表的后面附加一个节点，节点的值为carry。

初始时carry为0，然后循环条件时任一个链表不为空就继续。然后取出节点的值，为空则记为0，不为空就取出，然后两数相加再加上进位，进位carry已经初始化为0。然后计算carry用于下一轮的2个数相加，carry=(val1+val2+carry)/10。而当前求和的数字是 (val1+val2+carry)%10，这个值作为一个节点被new出来，如果它作为要返回的链表的头节点，头节点就等于它，否则就让新链表的节点的下一个指向它。

### stack解法

不允许反转链表的情况下，使用栈将链表逆序即可。

然后要注意的是，栈存储的顺序和链表的顺序是一样的，只不过取出数字是从尾部取，使用pop_back或者pop即可。然后因为计算出的数字是高位的数字和进位，所以要创建一个节点来接在哑节点后面，总是以dummy->next构造。

## 旋转链表

给你一个链表的头节点head旋转链表，将链表每个节点向右移动k个位置，后面的元素会重新移动到链表首端，类似于循环链表。

### iteration解法

从0开始计数，位置0的节点向前1个单位变成1，向前移动n-1次，就到达位置n-1，此时还没有完整的循环一遍。移动n次时节点0又回到了节点0原本的位置。如果123456，k=2不是想要输出345612，而是561234，这其实就是首节点向前移动，新的首节点对应原来链表在位置length-k的那个节点，但是要考虑k是整数倍length的情况，必须对length取余。 firstIdx = k%length==0?0:length-k%length，如果k是length的倍数，firstIdx=0即可，否则它应该是length-k%length。而lastIdx在firstIdx不为0的情况下等于firstIdx-1即可，否则直接等于length-1，即lastIdx = firstIdx==0?length-1:firstIdx-1。现在iter位置在length-1，首先让它指向头节点成环，然后从位置length-1到lastIdx共lastIdx+1个单位，故它向前移动lastIdx+1个单位即可到达新的链表尾节点。然后它的下一个就是首节点被返回即可，然后断开尾节点和首节点的联系。

## 奇偶链表

把奇数索引1、3、5上的元素都移到后边，偶数的移到前边。

### iteration解法

每个节点都是奇数节点或偶数节点。头节点是奇数节点，头节点的后一个节点是偶数节点，相邻节点的奇偶性不同。因此可以将奇数节点和偶数节点分离成奇数链表和偶数链表，然后将偶数链表连接在奇数链表之后，合并后的链表即为结果链表。

原始链表的头节点head也是奇数链表的头节点以及结果链表的头节点，head的后一个节点是偶数链表的头节点。令 evenHead=head.next，则 evenHead 是偶数链表的头节点。维护两个指针odd和even分别指向奇数节点和偶数节点，初始时odd=head，even= evenHead。通过迭代的方式将奇数节点和偶数节点分离成两个链表，每一步首先更新奇数节点，然后更新偶数节点，这个原因是因为位置0是奇数节点。

更新奇数节点时，奇数节点的后一个节点需要指向偶数节点的后一个节点，因此令odd.next=even.next，然后令odd=odd.next，更新odd指向下一个奇数节点，此时odd变成even的后一个节点。更新偶数节点时，偶数节点的后一个节点需要指向奇数节点的后一个节点，因此令even.next=odd.next，然后令even=even.next，更新even指向下一个偶数节点，此时even变成odd的后一个节点。

全部节点分离完毕的条件是even为空节点或者even.next为空节点，此时odd指向最后一个奇数节点(即奇数链表的最后一个节点)。最后令odd.next=evenHead，将偶数链表连接在奇数链表之后，即完成了奇数链表和偶数链表的合并，结果链表的头节点仍然是head。

## 移除链表元素

和有序链表去重、删除重复项都不同，去重是任何元素都只保留一个，删除重复项是重复的(2个及以上)都删除不保留。本题是指定大小的元素被移除。

### iteration解法

用cur表示当前节点。如果cur的下一个节点不为空且下一个节点的节点值等于给定的val，则需要删除下一个节点。删除下一个节点可以通过cur.next = cur.next.next，就断开了被删除节点的链接。但是这个节点依然指向cur.next.next，最好将其置为空删除。下一个节点的节点值不等于给定的val，则保留下一个节点，将cur移动到下一个节点即可。下一个节点为空时，链表遍历结束，此时所有节点值等于val的节点都被删除。由于链表的头节点head 有可能需要被删除，因此创建哑节点dummy，令 dummy.next=head，初始化cur=dummy，然后遍历链表进行删除操作。最终返回dummynext 即为删除操作后的头节点。

### recursion解法

递归的终止条件是head为空，此时直接返回 head。当head不为空时，递归地进行删除操作，然后判断head 的节点值是否等于val 并决定是否要删除head。

## 反转链表

### iteration解法

从当前节点开始，用cur表示，用prev表示cur的前1个节点(初始位nullptr)，next表示cur的后1个节点，遍历链表的每个节点：第一步让cur的next指向prev，第二步让prev向前移动，也就是等于cur，第三步，让cur向前移动等于cur的next，直到cur为nullptr为止。注意第二步和第三步不能反过来，因为cur要在被cur.next覆盖之前提前交给prev。

### recursion解法

假设第nk个节点之后的节点已经被反转，但是nk-1及之前的节点没有被反转，就处于下面的状态。

n1 -> n2 -> ... -> nk-1 -> nk -> nk+1 <- nk+2 <- nk+3 <- ... <- nk+m

首先不断的递归到最深处，此时到达最后1个节点last，最后1个节点的next是nullptr或者last是nullptr时直接返回last；

然后第一轮退栈，此时当前节点是倒数第二个节点cur，让它的next的next指回自己，也就是last.next=cur，这就让最后1个节点last反转了指向。但是因为cur的next也指向了last，这形成了互指，所以让cur的next断开指向nullptr，cur的next会在下一轮递归指向cur的前一个节点prev。第一轮返回的仍然是last，因为多轮递归能满足返回条件的只有last，其它节点不是nullptr，它们的next也不是nullptr，所以不会返回任何东西；

第二轮退栈，同理cur变成了prev，此时让cur.next.next=cur，就是让prev的后1个节点的next指回prev，然后断开cur的连接避免互指，也就是prev的next=nullptr，之后同理不会返回任何东西，如此反复。

## 合并两个有序链表

### recursion解法

每次比较的共同的点是：如果第1个链表的节点是空，就返回第2个链表的节点；如果第2个链表的节点是空，就返回第1个链表的节点；如果均不为空，那么应当更新某个链表节点的next指向。如果第1个链表节点的值小于第2个链表节点的值，说明以第1个节点为基础即可，然后更新第1个节点的next，而这个next的值取决于第1个节点next的值和第2个节点的值熟大熟小。当然也可以是第2个链表节点的值比较大，那就用第2个节点的next和第1个节点去比较，来更新第2个节点的next。

这样反复递归下去，直到最后有1个链表节点是空的，就开始执行退栈过程，这个空节点作为上个节点的next，上个节点又作为上上个节点的next，一路退到最后，就是真正的list1或者list2了。

### iteration解法

我自己的解法：

首先判断均为空的情况，直接返回空指针；只要不均为空，就可以循环，所以while的条件是list1为空或者list2为空。先设定1个指针t，已经初始化过，指向某个地址，然后再用ans记录这个地址，之后更新的是t->next，ans记录的是最初的t，t更新为t->next不会影响ans。

然后先考虑均不为空的情况，那么就可以比较2个值，比较之后，让t的值等于更小的那个值，然后更新t为t->next，同时也更新那个更小的list1或list2为其next。这个操作的前提是，t在更新为t->next之前，要先给t->next新建new1个节点，否则t更新完是空指针，下次再比较就会出问题。如果2个值相等，只需要让t和t->next的值都等于这个值，然后同理t更新到t->next->next之前都要事先new出个节点，再去更新list1和list2指向自己的下一个节点。但是这样可能会导致，list1和list2更新完后while直接退出。t多new了个节点，默认的值为0，所以还要加个判断条件，如果更新完后list1和list2都为空，先把new出来的t->next->next置为nullptr，再退出while，再返回ans；

如果2个节点有1个为空，直接让t的值等于非空节点的值，让t->next和非空节点的next相等接上即可，因为链表已经有序，直接退出循环。

官方解法：

前边是比较类似的程序，先设定t=new的节点，再让ans等于这个节点记录最初的t地址，但是这个节点当作是第1个节点的前1个节点。然后思路是，两个节点均不为空作为while条件，然后去比较2个节点的值，然后更新t的next为list1或list2的next；while结束以后至多有1个节点不为空，因为已经有序，让t直接接上非空节点即可。

## 找出链表相交节点

### doublePointers解法

两个链表均不为空时才可能相交，如果有一个为空直接返回nullptr。

均不为空时，定义指向两个链表头节点的指针pa和pb，如果pa不为空就移动pa到下一个节点，pb也是如此；直到某个指针遇到了空节点，例如pa遇见空节点，则让它重新指向b链表的头节点，然后一样pa不为空就更新，pb也是如此遇到空节点会指向a链表的头节点；直到pa和pb都指向同1个节点或者都指向空节点，就返回同一节点的地址或者mullptr。

找出相交节点的问题，大类上考虑2种情况，即测试案例是相交的和不相交的。

首先考虑2个链表确实有相交节点，如果2个链表的非相交节点个数是相同的，因为相交节点也是相同的，那么相交节点之间的那些非相交节点个数必定是相同的，那么一开始两个指针会同时到达相交节点，直接返回了；

如果2个链表非相交节点个数不同，也就是相交节点之前的那些节点个数不同，那么就不会同时到达相交节点，两个指针各自到达空节点后就会移动到对方的头节点身上。那么一开始指向较短链表头节点的指针，先到达空节点，然后移动到较长链表的头节点，再到相交节点，走过的路径为短链表的长度+长链表相交节点之前的节点；一开始指向较长链表头节点的指针，后到达空节点，再跳到较短链表的头节点，走过的路径为长链表的长度+短链表相交节点之前的节点；其实这两个路径是相同的，即两个指针会在第一次错过同时到达相交节点后，再次会同时到达相交节点。

如果2个链表每月相交节点，也就会同时到达空节点，返回nullptr。

### hashSet/hashTable解法

把链表A的所有节点地址用一个哈希集合或哈希表存起来，因为每个节点的地址是唯一的，所以哈希表或集合中所有地址是唯一的，链表B和链表A相同的那个地址存在说明相交，返回即可。

注：用哈希表其实也是可以的，因为存储的是节点地址，唯一就正确，只是时间变慢需要156ms，而哈希集合只需要80ms，双指针法更快，40ms。

set和map是不同的，<unordered_set> 和 <unordered_map>也是不同的。

① map和unordered_map的区别

 unordered_map存储机制是哈希表，不会根据key的大小进行排序，存储时根据key的hash值判断元素是否相同，内部元素是无序的。调用count函数返回被查找的元素个数只能是0或者1，unordered_map可类比于Python中的字典dict。

map中的元素是按照二叉搜索树(红黑树)存储，是有序的，在红黑树上查找的时间复杂度是O(logN)，相对于unordered_map的查询速度有所下降，但额外空间开销减小，map进行中序遍历会得到有序遍历。

如果需要内部元素自动排序，使用map，不需要排序使用unordered_map。

②set和unordered_set的区别

unordered_set基于哈希表，是无序的，unordered_set可类比于Python中的集合set。

set实现了红黑树的平衡二叉检索树的数据结构，插入元素时，它会自动调整二叉树的排列，把元素放到适当的位置，以保证每个子树根节点键值大于左子树所有节点的键值，小于右子树所有节点的键值；另外，还得保证根节点左子树的高度与右子树高度相等。平衡二叉检索树使用中序遍历算法，检索效率高于vector、deque和list等容器，另外使用中序遍历可将键值按照从小到大遍历出来。

③unordered_map和unordered_set的区别

set没有键值，本身就是键值。

## 对有序链表去重

### doublePointers解法

先判断root是否为空，是返回None；不是继续判断root的next是否为空，是直接返回root；不是说明至少有2个元素，使用双指针，一个fast指向root的next，另一个slow以root构建1个节点，定义ans指向初始的slow。

当fast和fast->next有一个为真时，while循环就继续。

否则判断fast和slow的值是否相等，不等则slow->next以fast的值去构建新节点，移动slow和fast到next节点。然后检测fast是否为空，为空直接退出while，这是防止fast更新为null节点后会因为比较2个值是否相等而导致错误，空指针没有val属性。

如果相等，就定义小while循环，当fast始终和slow值相等时，就会让fast更新到next，因为链表事先是有序的，也要检测fast是否为空，是退出小循环。退出小循环后，fast因为可能是空节点，所以也要继续检测fast，退出大循环。如果不是，就可以让slow->next以fast的值去构建新节点，更新slow到next。

### iteration解法

这个方法其实和双指针解法类似，但是区别在于无需使用new，空间复杂度变小，直接利用原有的root即可。

## 删除有序链表重复项

和上一道题的区别是，如果有重复的节点都不保留，而上边的重复项会保留1个。

### iteration解法

定义一个节点p，让它的下一个节点是root。然后p的next的next不为空时，就比较p的next和p的next.next，就更新p为p.next。这个意思是，一个节点后面的2个节点不相等，才能保证第1个节点确实不是重复的，才会更新当前节点为这后面的节点。要注意，p.next更新完后可能为空节点，加个判断提前退出，否则空节点是没有next属性的，大while会出错。

否则的话从这个节点后面的第1个节点开始，记录这个节点的值x，只要p.next的值没变，就更新p.next，注意：是更新p.next为p.next.next，直到不等于这个值为止，说明p.next确实不是重复项了再更新p为p.next。还要注意p.next可能更新为None的情况，要判断提前退出，否则空节点是没有val的，无法与x比较。

双指针其实也可以，但是写出来基本上和迭代法没有太多差异，不在给出。

## 删除链表倒数第n个节点

### iteration解法

先计算链表的长度，根据长度确定要移除节点的前一个节点，让这个节点的next直接指向节点的next.next即可，但是要注意移除的这个节点是否是第1个节点，如果是，直接让next为空即可。

### doublePointers解法

依据数学计算公式，假设有m个节点，要移除的是倒数第n个节点，以编号1开始的话，移除的节点位置是n-m+1，所以需要到达第n-m个节点，让它的next执行next.next即可。有个特殊情况时，n=m的时候，其实移除的就是第1个节点，因为没有第0个节点，所以这个情况要特殊处理。

定义2个指针fast和slow，一开始都指向root。现在只有一个数n，利用n可以先让fast指针到达第n+1个节点的位置。因为n可以为m，所以fast指针移动后可以是空指针，即移动m次，此时作为特殊情况，直接返回slow的next即可，因为删除的是第1个节点；如果n不为m，因为fast已经在n+1的位置，凑出n-m，自然是先让m减去n+1，也就是让fast移动到最后1个节点，位置为m，所以这样while执行了n-m-1次，判断条件是fast->next不为空，同时slow也更新。因为slow本来是在1的位置，所以移动n-m-1次就到达了位置n-m，此时让slow->next=slow->next->next即可。

### stack解法

用栈把链表的每个节点都入栈，由于栈先入后出，所以可以把栈的前n个top删掉，再次获取top就是要删除的节点的前驱节点，让它的next指向next.nex即可。

## 判断是否为环形链表

### hashTable解法

遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。那么遍历的时候用map来存储，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。

### doublePointers解法

快指针初始指向root.next，慢指针指向root，快指针每次移动2步，慢指针1步，如果2个有1个到达了nullptr就说明不是环链表，否则一定某时刻追上，两个指针指向同一个节点，所以相等时就返回true。不过因为一开始fast指向root.next，所以要事先判断一下root.next，如果为nullptr就不是环，否则，第2个节点可以接回第1个节点或者下一个节点，那就比较2个指针的信息即可。

## 对链表进行插入排序

### iteration解法

插入排序：初始有1个元素，之后每次总是插入合适的位置使之有效，如果是数组的插入排序，插入排序位置后面的元素都要向后移动一位，而且数组事先得多申请内存。如果是链表，只需要插入位置前的节点的next和插入的节点连接上即可，然后让插入的节点连上前一个节点原本的next。不过由于找到插入位置需要从头遍历，所以时间复杂度实际上还是O(n^2)。

首先判断给定的链表是否为空，若为空，则不需要进行排序，直接返回。

引入哑节点，便于在head节点之前插入节点，可以让dummy.next=root。

设定1个指针lastSorted指向链表的已排序部分的最后1个节点，因为插入排序初始有1个元素，从第2个元素开始，已排序的就是第1个，所以初始指向root。设定待插入的元素为cur，从第2个元素开始，初始为root.next，这里可以知道cur总是lastSorted的后1个节点。比较lastSorted和cur的值，决定插入位置，如果cur大就直接插在后边，更新lastSorted为cur；cur小就与lastSorted的前一个继续去比较，这个节点用prev来维护，不过由于链表的单向性，只能让prev指向dummy节点，当它的下一个还小于cur的时候，就移动prev，否则说明prev到达了比cur小的最大节点。这个时候lastSorted不用动，但是它的下一个不再是cur，因为cur跑到前边了，那么cur的next接在lastSorted的next即可。然后cur的next接上原本prev的next，prev的next更新为新节点cur。

以上操作是在cur不为空节点时就执行，运行结束后，dummy节点后边就排好了，返回dummy->next即可。
