## 解题思路

## 找到数组的最大和最小值

### iteration解法

用两个变量记录目前最大和最小的值索引，根据数组大小n的情况来决定返回。

如果n=0，什么都没有；n=1，则最大和最小索引都是0；

如果n>1，还要判断n的奇偶性，如果是奇数，则初始最大最小值索引都从0开始，循环起始点为1；如果是偶数，就先比较a[0]和a[1]的情况，然后大的那个索引为maxIndex，小的给minIndex，循环起始点为2；这样可以保证后边的元素总是两两成对，便于比较；

开始每2个元素一组进行比较，大的那个元素和a[maxIndex]去比较，小的那个元素和a[minIndex]去比较，必要的话更新maxIndex和minIndex的值，循环结束就可以得到结果。

### recursion解法

借助分而治之的思想，这个解法是反复二分数组，直到最小单元2个或1个元素的数组，也就是当n不等于2的时候就会持续下去。如果是2个元素，用2个变量分别记录更小和更大的元素；如果是1个元素，最小和最大都是1个元素。

如果首次进入，n为0就返回2个None；如果是再次进入的，因为二分后数组的奇偶性可能发生变化，所以数组长度可能是1，则最大最小值认为是a[0]，数组调整长度为a[1:]就是[]了，这时候应当直接返回最大最小值；同理，数组长度可能是2，则最大最小值为{a[0],a[1]}或{a[1],a[0]}，调整数组的长度为a[2:]也是[]，应当直接返回，这是递归真正的终止条件。

例如，先判断n不为0以后，假设a还有2个或3个元素。此时再判断a是否等于2，如果等于2，二分后就是2个包含1个元素的数组；如果等于3，1个数组1个元素，另1个数组2个元素。然后再次进入递归，就遇见上一段所说的递归终止条件，无论是1个元素还是2个元素都会直接返回，不会再递归入栈，会不断递归退栈。

这个方法的缺点是不知道索引最大最小值在数组的位置，因为数组每次二分这个索引值就不再是原来整个数组的真实索引值了，只是各自小数组的索引位置。如果想通过这一系列小数组的索引位置倒退原数组真实的索引位置，比较困难。

另外递归法的速度甚至慢于纯循环方法，更不比说上边优化过的循环方法，代码文件测试，10000000个元素的量级下，递归花费7.16s，纯循环花费4.9s，上述优化的循环方法花费3.77s。







